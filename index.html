<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ycchildcoder">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="ycchildcoder">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="ycchildcoder">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>ycchildcoder</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ycchildcoder</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/27/blog/go%20%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/27/blog/go%20%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">go 注意事项</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-27 17:50:31 / Modified: 18:47:20" itemprop="dateCreated datePublished" datetime="2022-01-27T17:50:31+08:00">2022-01-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="请说出下面代码，执行时为什么会报错"><a href="#请说出下面代码，执行时为什么会报错" class="headerlink" title="请说出下面代码，执行时为什么会报错"></a>请说出下面代码，执行时为什么会报错</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]Student&#123;<span class="string">&quot;people&quot;</span>: &#123;<span class="string">&quot;zhoujielun&quot;</span>&#125;&#125;</span><br><span class="line">	m[<span class="string">&quot;people&quot;</span>].name = <span class="string">&quot;wuyanzu&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析：<br>map的value本身是不可寻址的，因为map中的值会在内存中移动，并且旧的指针地址在map改变时会变得无效。故如果需要修改map值，可以将<code>map</code>中的非指针类型<code>value</code>，修改为指针类型，比如使用<code>map[string]*Student</code>.</p>
<h3 id="2、写出打印的结果。"><a href="#2、写出打印的结果。" class="headerlink" title="2、写出打印的结果。"></a>2、写出打印的结果。</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	js := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">		&quot;name&quot;:&quot;11&quot;</span></span><br><span class="line"><span class="string">	&#125;`</span></span><br><span class="line">	<span class="keyword">var</span> p People</span><br><span class="line">	err := json.Unmarshal([]<span class="keyword">byte</span>(js), &amp;p)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err: &quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;people: &quot;</span>, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p>按照 golang 的语法，小写开头的方法、属性或 <code>struct</code> 是私有的，同样，在<code>json</code> 解码或转码的时候也无法上线私有属性的转换。</p>
<p>题目中是无法正常得到<code>People</code>的<code>name</code>值的。而且，私有属性<code>name</code>也不应该加<code>json</code>的标签。</p>
<h3 id="3、sync-Map-的用法"><a href="#3、sync-Map-的用法" class="headerlink" title="3、sync.Map 的用法"></a>3、sync.Map 的用法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> m sync.Map</span><br><span class="line">	m.Store(<span class="string">&quot;address&quot;</span>,<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;province&quot;</span>:<span class="string">&quot;江苏&quot;</span>,<span class="string">&quot;city&quot;</span>:<span class="string">&quot;南京&quot;</span>&#125;)</span><br><span class="line">        v,_ := m.Load(<span class="string">&quot;address&quot;</span>)</span><br><span class="line">	fmt.Println(v[<span class="string">&quot;province&quot;</span>]) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A，江苏；</li>
<li>B<code>，v[&quot;province&quot;]</code>取值错误；</li>
<li>C，<code>m.Store</code>存储错误；</li>
<li>D，不知道</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p><code>invalid operation: v[&quot;province&quot;] (type interface &#123;&#125; does not support indexing)</code> 因为 <code>func (m *Map) Store(key interface&#123;&#125;, value interface&#123;&#125;)</code> 所以 <code>v</code>类型是 <code>interface &#123;&#125;</code> ，这里需要一个类型断言</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(v.(map[string]string)[&quot;province&quot;]) //江苏</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m sync.Map</span><br><span class="line">	m.Store(<span class="string">&quot;address&quot;</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;province&quot;</span>: <span class="string">&quot;江苏&quot;</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;南京&quot;</span>&#125;)</span><br><span class="line">	v, _ := m.Load(<span class="string">&quot;address&quot;</span>)</span><br><span class="line"></span><br><span class="line">	tmp, ok := v.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(tmp[<span class="string">&quot;province&quot;</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//if tmp,ok := v.(map[string]string);ok&#123;</span></span><br><span class="line">	<span class="comment">//	</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//fmt.Println(v[&quot;province&quot;])</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、知道golang的内存逃逸吗？什么情况下会发生内存逃逸？"><a href="#4、知道golang的内存逃逸吗？什么情况下会发生内存逃逸？" class="headerlink" title="4、知道golang的内存逃逸吗？什么情况下会发生内存逃逸？"></a>4、知道golang的内存逃逸吗？什么情况下会发生内存逃逸？</h3><h2 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h2><p>golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在堆上分配。</p>
<p>能引起变量逃逸到堆上的典型情况：</p>
<ul>
<li><strong>在方法内把局部变量指针返回</strong> 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。</li>
<li><strong>发送指针或带有指针的值到 channel 中。</strong> 在编译时，是没有办法知道哪个 <code>goroutine</code> 会在 <code>channel</code> 上接收数据。所以编译器没法知道变量什么时候才会被释放。</li>
<li><strong>在一个切片上存储指针或带指针的值。</strong> 一个典型的例子就是 <code>[]*string</code> 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。</li>
<li><strong>slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。</strong> slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。</li>
<li><strong>在 interface 类型上调用方法。</strong> 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。</li>
</ul>
<h3 id="5、对已经关闭的的-chan-进行读写，会怎么样？为什么？"><a href="#5、对已经关闭的的-chan-进行读写，会怎么样？为什么？" class="headerlink" title="5、对已经关闭的的 chan 进行读写，会怎么样？为什么？"></a>5、对已经关闭的的 chan 进行读写，会怎么样？为什么？</h3><h2 id="回答-1"><a href="#回答-1" class="headerlink" title="回答"></a>回答</h2><ul>
<li>读已经关闭的 chan 能一直读到东西，但是读到的内容根据通道内关闭前是否有元素而不同。<ul>
<li>如果 chan 关闭前，buffer 内有元素还未读 , 会正确读到 chan 内的值，且返回的第二个 bool 值（是否读成功）为 true。</li>
<li>如果 chan 关闭前，buffer 内有元素已经被读完，chan 内无值，接下来所有接收的值都会非阻塞直接成功，返回 channel 元素的零值，但是第二个 bool 值一直为 false。</li>
</ul>
</li>
<li>写已经关闭的 chan 会 panic</li>
</ul>
<h3 id="Go编码注意事项"><a href="#Go编码注意事项" class="headerlink" title="Go编码注意事项"></a>Go编码注意事项</h3><ol>
<li><p>new和make的区别,前者返回的是<strong>指针</strong>，后者返回引用，还能给这个内存的<strong>类型初始化其零值</strong>，且make关键字只能创建channel、slice和map这三个引用类型。</p>
</li>
<li><p>如果User结构想实现Test方法，以下写法：<code>func (this *User) Test() </code>，User的实例和*User都可以调到Test方法，不同的是作为接口时User没有实现Test方法。</p>
</li>
<li><p>interface　<strong>作为两个成员实现，一个是类型和一个值</strong>，<code>var x interface&#123;&#125; = (*interface&#123;&#125;)(nil)</code>　接口指针x不等于nil  。下面一段代码深入展示：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id   <span class="keyword">int</span></span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Tester</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Tester <span class="keyword">interface</span> &#123;</span><br><span class="line">    Test()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *User)</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(this)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span> <span class="title">Tester</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x *User = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x Tester = create()</span><br><span class="line">    <span class="keyword">if</span> x != <span class="literal">nil</span> &#123;</span><br><span class="line">       t.Log(<span class="string">&quot;not nil &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> u *User = x.(*User)</span><br><span class="line">    <span class="keyword">if</span> u == <span class="literal">nil</span> &#123;</span><br><span class="line">       t.Log(<span class="string">&quot;nil &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>继承通过嵌入实现，也可说go语言没有继承语法。</p>
</li>
<li><p>import关键字前面的”.”和”_”的用法，点号表示调用这个包的函数时可以省去包名，下划线表示纯引入包，因为go语法内没有使用这个包是不能导入的，包引入了，系统会自动调用包的init函数。</p>
</li>
<li><p>select case必须是chan的io操作，为了避免饥饿问题，当多个通道都同时监听到数据时，select机制会随机性选择一个通道读取，一个通道被多个select语句监听时，同理。</p>
</li>
<li><p>关闭通道时所有select 监听都会收到通道关闭信号，某种意义上<strong>关闭通道是广播事件</strong>。</p>
</li>
<li><p>goroutine的panic如果没有捕获，整个应用程序会crash ,所以安全起见每个复杂的<strong>go线程都要recover</strong>。</p>
</li>
<li><p>在函数退出时，defer的调用顺序是写在后面的先被调用。</p>
</li>
<li><p>init函数在main之前调用，被编译器自动调用，每个包理论上允许有多个init函数,编码上尽量避免同一个包内出现多个init函数。</p>
</li>
<li><p>panic可以中断原有的控制流程，进入一个令人恐慌的流程中,这一过程继续向上，直到发生panic的goroutine中所有调用的函数返回，此时程序退出。恐慌可以直接调用panic产生。也可以由运行时错误产生，例如访问越界的数组.<br>recover的用法,recover可以让进入令人恐慌的流程中的goroutine恢复过来。<strong>recover仅在defer函数中有效</strong>。在正常的执行过程中，调用recover会返回nil，并且没有其它任何效果。</p>
</li>
<li><p>Array 和Slice的区别，<strong>Array就是一个数据块，值类型</strong>而非引用类型，传参时会进行内存拷贝，Slice是个<code>reflect.SliceHeader</code>结构体。Slice由make函数或者Array[:]创建。</p>
</li>
<li><p>闭包要注意循环调用时，upvalue值一不留意可能只是循环退出的值。如下代码：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">    data ++</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">            listen2(data)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;- time.After(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen2</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Print( data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 输出：<code>26101010101010106</code>，跟你期望的输出可能不一样。</p>
</blockquote>
<ol start="14">
<li><p>普通类型向接口类型的转换是隐式的,定义该接口变量直接赋值。接口类型向普通类型转换需要<strong>类型断言</strong>：value, ok := element.(T)。</p>
</li>
<li><p>Go设计上模糊了堆跟栈的边界，go编译器帮程序员做了对象逃逸分析，优化了内存分配，t := T{}是可以在函数里返回的，并不是像C语言中在栈里分配内存了。</p>
</li>
<li><p>无论以接口或接口指针传递参数，接口指向的值都会被拷贝传递，引用类型（Map/Chan/Slice）拷贝该引用对象，值类型拷贝整个值（string除外）。</p>
</li>
<li><p>go线程的调用时机是由go runtime决定的。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i:= <span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">		<span class="keyword">go</span> listen2(i)</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;- time.After(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen2</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Print( data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 输出：<code>3456781209</code></p>
</blockquote>
<ol start="18">
<li><p>调用log.Fatal系列函数后，会再调用 os.Exit(1)　退出程序，<code>Fatal is equivalent to Print() followed by a call to os.Exit(1)</code>。</p>
</li>
<li><p>如果管道关闭则退出for循环，因为管道关闭不会阻塞导致for进入死循环,如下：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的做法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_Select_Chan</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	readerChannel:= <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span> )</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(readerChannel <span class="keyword">chan</span> <span class="keyword">int</span> )</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="comment">// 判断管道是否关闭</span></span><br><span class="line">			<span class="keyword">case</span> _, ok := &lt;-readerChannel:</span><br><span class="line">				<span class="keyword">if</span> !ok &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			t.Log(<span class="string">&quot;for&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(readerChannel)</span><br><span class="line">	<span class="built_in">close</span>(readerChannel)</span><br><span class="line">	&lt;- time.After(time.Second*<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确的做法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_Select_Chan1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	readerChannel:= <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span> )</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(readerChannel <span class="keyword">chan</span> <span class="keyword">int</span> )</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="comment">// 判断管道是否关闭</span></span><br><span class="line">			<span class="keyword">case</span> _, ok := &lt;-readerChannel:</span><br><span class="line">				<span class="keyword">if</span> !ok &#123;</span><br><span class="line">					<span class="keyword">goto</span> BB</span><br><span class="line">					<span class="comment">//return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			t.Log(<span class="string">&quot;for&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	BB:</span><br><span class="line">	&#125;(readerChannel)</span><br><span class="line">	<span class="built_in">close</span>(readerChannel)</span><br><span class="line">	&lt;- time.After(time.Second*<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>for select 组合不带标签的break语法是跳不出循环，如果要跳出循环，要设置goto 标签或者直接return返回</strong>。</p>
<ol start="20">
<li><code>map,slice,array,chan</code>的数据存取值类型数据都是值拷贝赋值，这个跟很多脚本语言不同，一定要注意:</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list []mydata</span><br><span class="line"><span class="keyword">var</span> hash <span class="keyword">map</span>[<span class="keyword">string</span>]mydata</span><br><span class="line"><span class="keyword">type</span> mydata <span class="keyword">struct</span> &#123;</span><br><span class="line">    A <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	list = <span class="built_in">make</span>([]mydata, <span class="number">1</span>)</span><br><span class="line">	data := list[<span class="number">0</span>]</span><br><span class="line">	data.A = <span class="number">10</span></span><br><span class="line">	hash = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]mydata)</span><br><span class="line">	hash[<span class="string">&quot;test&quot;</span>] = mydata&#123;&#125;</span><br><span class="line">	data = hash[<span class="string">&quot;test&quot;</span>]</span><br><span class="line">	data.A = <span class="number">10</span></span><br><span class="line">	t.Log(list[<span class="number">0</span>].A, hash[<span class="string">&quot;test&quot;</span>].A)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 输出：<code>0 0</code></p>
</blockquote>
<ol start="21">
<li>外部可见的属性必须是首字母大写，当转换到json数据是跟预期有偏差，必须添加json标签，如下：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CMD <span class="keyword">struct</span>&#123;</span><br><span class="line">        Cmd <span class="keyword">string</span> <span class="string">`json:&quot;cmd&quot;`</span></span><br><span class="line">        Data Data <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">        UserId <span class="keyword">string</span> <span class="string">`json:&quot;userId&quot;`</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="22">
<li><p>包的循环引用编译错误，解决方法：提取公共部分到独立的包或者定义接口依赖注入。</p>
</li>
<li><p><code>return XXX</code>不是一条原子指令：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Log(test())</span><br><span class="line">	t.Log(test1())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		result++</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	t := <span class="number">5</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		t = t + <span class="number">5</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 输出：<br> <code>2</code><br> <code>5</code></p>
</blockquote>
<p><code>return XXX </code>不是一条原子指令，<strong>函数返回过程是，先对返回值赋值，再调用defer函数，然后返回调用函数</strong><br>所以test方法的<code>return 1</code>可以拆分为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span><span class="params">(result <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    result ++</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<ol start="24">
<li>内置copy方法，拷贝数组时，如果要整数组拷贝，目标数组长度要和源数组长度相同，否则剩下的数据不会被拷贝:</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list := []<span class="keyword">int</span>&#123;<span class="number">12</span>, <span class="number">1242</span>, <span class="number">35</span>, <span class="number">23</span>, <span class="number">534</span>, <span class="number">23</span>, <span class="number">1</span>&#125;</span><br><span class="line">listNew := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1</span>, <span class="built_in">len</span>(list))</span><br><span class="line"><span class="built_in">copy</span>(listNew, list)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(listNew); i++ &#123;</span><br><span class="line">fmt.Println(listNew[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 输出：<code>12</code></p>
</blockquote>
<ol start="25">
<li>分割切片slice时，新切片引用的内存和老切片引用的是同一块内存:</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list := []<span class="keyword">int</span>&#123;<span class="number">12</span>, <span class="number">1242</span>, <span class="number">35</span>, <span class="number">23</span>, <span class="number">534</span>, <span class="number">23</span>, <span class="number">1</span>&#125;</span><br><span class="line">listNew := list[:<span class="number">3</span>]</span><br><span class="line">listNew2 := list[:<span class="number">5</span>]</span><br><span class="line">listNew[<span class="number">1</span>] = <span class="number">999</span></span><br><span class="line">fmt.Println(listNew2[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 输出：<code>999</code></p>
</blockquote>
<ol start="26">
<li><p><strong>编译时设置编译参数去掉调试信息</strong>，可以让生成体积更小：<br><code>go build  -o target.exe -ldflags &quot;-w -s&quot; source.go</code></p>
</li>
<li><p>Go语言里，string字符串类是不可变值类型，字符串的”+”连接操作、字符串和字符数组之间的转换string([]byte) 都会生成新的内存存放新字符串，当要对字符串频繁操作时做好先转换成字符数组。但是字符串作为参数传参时，此处go编译器作了优化，不会导致内存拷贝，引用的是同一块内存。benchmark如下：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_aa</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	very_long_string:= <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		very_long_string += <span class="string">&quot;test &quot;</span> + <span class="string">&quot;and test &quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_bb</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	very_long_string:= []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		very_long_string = <span class="built_in">append</span>(very_long_string,[]<span class="keyword">byte</span>(<span class="string">&quot;test &quot;</span>)...)</span><br><span class="line">		very_long_string = <span class="built_in">append</span>(very_long_string,[]<span class="keyword">byte</span>(<span class="string">&quot;and test &quot;</span>)...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 输出：<br> <code>200000        135817 ns/op</code><br> <code>50000000            39.3 ns/op</code></p>
</blockquote>
<ol start="28">
<li><p>Go build/run/test 有个参数 -race  ，设置-race运行时会进行数据竞态检测，并把关键代码打印输出，不过数据竞态不能全依赖race检测,不一定能全部检测出来。</p>
</li>
<li><p>如果非必要必要使用反射reflect和unsafe包内的函数，一定要使用时，要用runtime.KeepAlive函数告知SSA编译器在指定的代码段内不要回收该内存块。</p>
</li>
<li><p>不要打印整个map对象或者对象里有嵌套map的对象，打印函数会不加锁遍历map的每个元素，如果此时外部刚好有方法对map进行写操作，map就进入并发读写，runtime会panic。</p>
</li>
<li><p>注意range 循环迭代时key 的地址，for k,v:=range list  其中<strong>k 在迭代时指向同一个地址</strong>。</p>
</li>
<li><p>append追加切片用法:</p>
</li>
</ol>
<ul>
<li>如果slice还有剩余的空间，可以添加这些新元素，那么append就将新的元素放在slice后面的空余空间中</li>
<li>如果slice的空间不足以放下新增的元素，那么就需要重现创建一个数组；这时可能是alloc、也可能是realloc的方式分配这个新的数组</li>
<li>也就是说，这个新的slice可能和之前的slice在同一个起始地址上，也可能不是一个新的地址</li>
<li>如果容量不足触发realloc，重新分配一个新的地址</li>
<li>分配了新的地址之后，再把原来slice中的元素逐个拷贝到新的slice中并返回</li>
<li>触发realloc时，容量小于1024，会扩展到原来的1倍，如果容量小大于1024，会扩展原来的1/4</li>
</ul>
<ol start="33">
<li>很多打印函数打印结构体时回调用该结构体的String方法，所以String不能再打印本身这个对象。如下：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this S)</span><span class="title">String</span><span class="params">()</span>  <span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprint( <span class="string">&quot;S struct: &quot;</span>,this )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_print</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> s S</span><br><span class="line">	t.Log(s.String())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// print 调用String</span></span><br></pre></td></tr></table></figure>

<p>34.循环语句里正整型迭代值边界问题，迭代值边界递减到负值，下面的代码会进入死循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:= <span class="keyword">uint8</span>(<span class="number">10</span>);i&gt;=<span class="number">0</span>;i--&#123;</span><br><span class="line">	t.Log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="35">
<li><p>recover只处理本goroutine调用栈，goroutine的panic如果没有捕获，整个应用程序会crash ,所以安全起见<strong>每个复杂的go线都要recover</strong>。</p>
</li>
<li><p>map 并发读写的错误无法用panic捕获。</p>
</li>
<li><p>对于小对象，直接将值类型的对象交由 map 保存，远比用该对象指针高效。这不但减少了堆内存分配，关键还在于<strong>垃圾回收器不会扫描非指针类型 key/value 对象。</strong></p>
</li>
<li><p>Go 使用 channel 实现 CSP 模型。处理双方仅关注通道和数据本身，无需理会对方身份和数量，以此实现结构性解耦。在各文宣中都有 “Don’t communicate by sharing memory, share memory by communicating.” 这类说法。但这并非鼓励我们不分场合，教条地使用 channel。在我看来，channel 多数时候适用于结构层面，而非单个区域的数据处理。原话中 “communicate” 本就表明一种 “message-passing”，而非 “lock-free”。所以，它并非用来取代 mutex，各自有不同的使用场景。</p>
</li>
<li><p>变量逃逸和函数内联状态分析 <code>go build -gcflags &quot;-m&quot; -o main.exe main.go </code>。</p>
</li>
<li><p>go汇编指令  <code>go build  -gcflags &quot;-N -l&quot; -o main.exe main.go &amp;&amp; go tool objdump -s &quot;main\.main&quot; main.exe</code>  关闭内联优化：<code>go build  -gcflags &quot;-N -l&quot;</code>。</p>
</li>
<li><p>关于defer机制，编译器通过 <code>runtime.deferproc</code> “注册” 延迟调用，除目标函数地址外，还会复制相关参数（包括 receiver）。在函数返回前，执行 <code>runtime.deferreturn</code> 提取相关信息执行延迟调用。这其中的代价自然不是普通函数调用一条 CALL 指令所能比拟的，单个函数里过多的 defer 调用可尝试合并。最起码，在并发竞争激烈时，<code>mutex.Unlock </code>不应该使用 defer，而应尽快执行，仅保护最短的代码片段。</p>
</li>
<li><p>对map预设容量，map会按需扩张，但须付出数据拷贝和重新哈希成本。如有可能，应尽可能预设足够容量空间，避免此类行为发生。</p>
</li>
<li><p>go语言调用c语言：</p>
</li>
</ol>
<ul>
<li>import “C”  这句代码必须紧跟伪注释的C语言代码后面不能有换行</li>
<li>go语言的CGO会自动链接编译.c文件，但是必须用go build 编译指令，不能指定main.go文件</li>
</ul>
<ol start="44">
<li>Go语言命名规范:</li>
</ol>
<ul>
<li><strong>文件命名，全小写+下划线</strong></li>
<li><strong>结构体名字、变量名字采用驼峰命名(根据包外可见性确定首字母是否大写)</strong></li>
<li><strong>常量命名，全大写 +下划线</strong></li>
</ul>
<ol start="45">
<li>删除切片的指定下标元素</li>
</ol>
<ul>
<li>低效的做法</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(array); j++ &#123;</span><br><span class="line">	<span class="keyword">if</span> INDEX == j &#123;</span><br><span class="line">		array = <span class="built_in">append</span>(array[:j], array[j+<span class="number">1</span>:]...)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>高效的做法</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">		</span><br><span class="line"><span class="keyword">for</span> j :=INDEX; j &lt; <span class="built_in">len</span>(array)<span class="number">-1</span>; j++ &#123;</span><br><span class="line">	array[j] = array[j+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">array = array[:<span class="built_in">len</span>(array)<span class="number">-1</span>]</span><br><span class="line">	</span><br></pre></td></tr></table></figure>












































      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/27/blog/test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/27/blog/test/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-27 11:37:58" itemprop="dateCreated datePublished" datetime="2022-01-27T11:37:58+08:00">2022-01-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/27/blog/linux-netstat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/27/blog/linux-netstat/" class="post-title-link" itemprop="url">netstat</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-27 10:42:23 / Modified: 11:37:07" itemprop="dateCreated datePublished" datetime="2022-01-27T10:42:23+08:00">2022-01-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><p>Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。</p>
<h1 id="输出信息含义"><a href="#输出信息含义" class="headerlink" title="输出信息含义"></a><strong>输出信息含义</strong></h1><p>执行netstat后，其输出结果为</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address Foreign Address State</span><br><span class="line">tcp 0 2 210.34.6.89:telnet 210.34.6.96:2873 ESTABLISHED</span><br><span class="line">tcp 296 0 210.34.6.89:1165 210.34.6.84:netbios-ssn ESTABLISHED</span><br><span class="line">tcp 0 0 localhost.localdom:9001 localhost.localdom:1162 ESTABLISHED</span><br><span class="line">tcp 0 0 localhost.localdom:1162 localhost.localdom:9001 ESTABLISHED</span><br><span class="line">tcp 0 80 210.34.6.89:1161 210.34.6.10:netbios-ssn CLOSE</span><br><span class="line"></span><br><span class="line">Active UNIX domain sockets (w/o servers)</span><br><span class="line">Proto RefCnt Flags Type State I-Node Path</span><br><span class="line">unix 1 [ ] STREAM CONNECTED 16178 @000000dd</span><br><span class="line">unix 1 [ ] STREAM CONNECTED 16176 @000000dc</span><br><span class="line">unix 9 [ ] DGRAM 5292 /dev/log</span><br><span class="line">unix 1 [ ] STREAM CONNECTED 16182 @000000df</span><br></pre></td></tr></table></figure>

<p>从整体上看，netstat的输出结果可以分为两个部分：</p>
<p>一个是<code>Active Internet connections</code>，称为有源TCP连接，其中<code>Recv-Q</code>和<code>Send-Q</code>指%0A的是接收队列和发送队列。这些数字一般都应该是0。如<strong>果不是则表示软件包正在队列中堆积</strong>。这种情况只能在非常少的情况见到。</p>
<p>另一个是<code>Active UNIX domain sockets</code>，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。</p>
<ul>
<li>  Proto显示连接使用的协议</li>
<li>  RefCnt表示连接到本套接口上的进程号</li>
<li>  Types显示套接口的类型</li>
<li>  Path表示连接到套接口的其它进程使用的路径名。</li>
<li>  Local Address代表本机IP地址和打开的端口号</li>
<li>  Foreign Address是远程计算机IP地址和端口号</li>
<li>State表明当前的连接状态<br>   &gt;  LISTENING 时表示处于侦听状态，就是说该端口是开放的，等待连接，但还没有被连接<br>   &gt;  ESTABLISHED 的意思是建立连接。表示两台机器正在通信。<br>   &gt;  CLOSE_WAIT 对方主动关闭连接或者网络异常导致连接中断,TIME_WAIT 我方主动调用close()断开连接，收到对方确认后状态变为TIME_WAIT</li>
</ul>
<h1 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a><strong>常见参数</strong></h1><p>-a (all)显示所有选项，默认不显示LISTEN相关<br>-t (tcp)仅显示tcp相关选项<br>-u (udp)仅显示udp相关选项<br>-n 拒绝显示别名，能显示数字的全部转化成数字。<br>-l 仅列出有在 Listen (监听) 的服務状态</p>
<p>-p 显示建立相关链接的程序名<br>-r 显示路由信息，路由表<br>-e 显示扩展信息，例如uid等<br>-s 按各个协议进行统计<br>-c 每隔一个固定时间，执行该netstat命令。</p>
<p>提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到</p>
<h1 id="实用命令实例"><a href="#实用命令实例" class="headerlink" title="实用命令实例"></a><strong>实用命令实例</strong></h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="1-列出所有端口-包括监听和未监听的"><a href="#1-列出所有端口-包括监听和未监听的" class="headerlink" title="1. 列出所有端口 (包括监听和未监听的)"></a><strong>1. 列出所有端口 (包括监听和未监听的)</strong></h2><p>列出相关连接的程序名都增加-p 参数</p>
<p> <u><strong>列出所有端口 netstat -a</strong></u></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -a | more</span></span><br><span class="line"> Active Internet connections (servers and established)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> tcp        0      0 localhost:30037         *:*                     LISTEN</span><br><span class="line"> udp        0      0 *:bootpc                *:*</span><br><span class="line"> </span><br><span class="line">Active UNIX domain sockets (servers and established)</span><br><span class="line"> Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line"> unix  2      [ ACC ]     STREAM     LISTENING     6135     /tmp/.X11-unix/X0</span><br><span class="line"> unix  2      [ ACC ]     STREAM     LISTENING     5140     /var/run/acpid.socket</span><br></pre></td></tr></table></figure>

<p> <u><strong>列出所有 tcp 端口 netstat -at</strong></u></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -at</span></span><br><span class="line"> Active Internet connections (servers and established)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> tcp        0      0 localhost:30037         *:*                     LISTEN</span><br><span class="line"> tcp        0      0 localhost:ipp           *:*                     LISTEN</span><br><span class="line"> tcp        0      0 *:smtp                  *:*                     LISTEN</span><br><span class="line"> tcp6       0      0 localhost:ipp           [::]:*                  LISTEN</span><br></pre></td></tr></table></figure>

<p> <u><strong>列出所有 udp 端口 netstat -au</strong></u></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -au</span></span><br><span class="line"> Active Internet connections (servers and established)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> udp        0      0 *:bootpc                *:*</span><br><span class="line"> udp        0      0 *:49119                 *:*</span><br><span class="line"> udp        0      0 *:mdns                  *:*</span><br></pre></td></tr></table></figure>

<h2 id="2-列出所有处于监听状态的-Sockets"><a href="#2-列出所有处于监听状态的-Sockets" class="headerlink" title="2. 列出所有处于监听状态的 Sockets"></a><strong>2. 列出所有处于监听状态的 Sockets</strong></h2><p>列出相关连接的程序名都增加-p 参数</p>
<p> <strong>只显示监听端口 netstat -l</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -l</span></span><br><span class="line"> Active Internet connections (only servers)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> tcp        0      0 localhost:ipp           *:*                     LISTEN</span><br><span class="line"> tcp6       0      0 localhost:ipp           [::]:*                  LISTEN</span><br><span class="line"> udp        0      0 *:49119                 *:*</span><br></pre></td></tr></table></figure>

<p> <strong>只列出所有监听 tcp 端口 netstat -lt</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -lt</span></span><br><span class="line"> Active Internet connections (only servers)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> tcp        0      0 localhost:30037         *:*                     LISTEN</span><br><span class="line"> tcp        0      0 *:smtp                  *:*                     LISTEN</span><br><span class="line"> tcp6       0      0 localhost:ipp           [::]:*                  LISTEN</span><br></pre></td></tr></table></figure>

<p> <strong>只列出所有监听 udp 端口 netstat -lu</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -lu</span></span><br><span class="line"> Active Internet connections (only servers)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line"> udp        0      0 *:49119                 *:*</span><br><span class="line"> udp        0      0 *:mdns                  *:*</span><br></pre></td></tr></table></figure>

<p> <strong>只列出所有监听 UNIX 端口 netstat -lx</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -lx</span></span><br><span class="line"> Active UNIX domain sockets (only servers)</span><br><span class="line"> Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line"> unix  2      [ ACC ]     STREAM     LISTENING     6294     private/maildrop</span><br><span class="line"> unix  2      [ ACC ]     STREAM     LISTENING     6203     public/cleanup</span><br><span class="line"> unix  2      [ ACC ]     STREAM     LISTENING     6302     private/ifmail</span><br><span class="line"> unix  2      [ ACC ]     STREAM     LISTENING     6306     private/bsmtp</span><br></pre></td></tr></table></figure>

<h2 id="3-显示每个协议的统计信息"><a href="#3-显示每个协议的统计信息" class="headerlink" title="3. 显示每个协议的统计信息"></a><strong>3. 显示每个协议的统计信息</strong></h2><p> <strong>显示所有端口的统计信息 netstat -s</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -s</span></span><br><span class="line"> Ip:</span><br><span class="line"> 11150 total packets received</span><br><span class="line"> 1 with invalid addresses</span><br><span class="line"> 0 forwarded</span><br><span class="line"> 0 incoming packets discarded</span><br><span class="line"> 11149 incoming packets delivered</span><br><span class="line"> 11635 requests sent out</span><br><span class="line"> Icmp:</span><br><span class="line"> 0 ICMP messages received</span><br><span class="line"> 0 input ICMP message failed.</span><br><span class="line"> Tcp:</span><br><span class="line"> 582 active connections openings</span><br><span class="line"> 2 failed connection attempts</span><br><span class="line"> 25 connection resets received</span><br><span class="line"> Udp:</span><br><span class="line"> 1183 packets received</span><br><span class="line"> 4 packets to unknown port received.</span><br><span class="line"> .....</span><br></pre></td></tr></table></figure>

<p> <strong>显示 TCP 或 UDP 端口的统计信息 netstat -st 或 -su</strong></p>
<h2 id="4-在-netstat-输出中显示-PID-和进程名称-netstat-p"><a href="#4-在-netstat-输出中显示-PID-和进程名称-netstat-p" class="headerlink" title="4. 在 netstat 输出中显示 PID 和进程名称 netstat -p"></a><strong>4. 在 netstat 输出中显示 PID 和进程名称 netstat -p</strong></h2><p>netstat -p 可以与其它开关一起使用，就可以添加 “PID/进程名称” 到 netstat 输出中，这样 debugging 的时候可以很方便的发现特定端口运行的程序。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -pt</span></span><br><span class="line"> Active Internet connections (w/o servers)</span><br><span class="line"> Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line"> tcp        1      0 ramesh-laptop.loc:47212 192.168.185.75:www        CLOSE_WAIT  2109/firefox</span><br><span class="line"> tcp        0      0 ramesh-laptop.loc:52750 lax:www ESTABLISHED 2109/firefox</span><br></pre></td></tr></table></figure>

<h2 id="5-在-netstat-输出中不显示主机，端口和用户名-host-port-or-user"><a href="#5-在-netstat-输出中不显示主机，端口和用户名-host-port-or-user" class="headerlink" title="5. 在 netstat 输出中不显示主机，端口和用户名 (host, port or user)"></a><strong>5. 在 netstat 输出中不显示主机，端口和用户名 (host, port or user)</strong></h2><p>当你不想让主机，端口和用户名显示，使用 netstat -n。将会使用数字代替那些名称。</p>
<p>同样可以加速输出，因为不用进行比对查询。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -an</span></span><br></pre></td></tr></table></figure>

<p>如果只是不想让这三个名称中的一个被显示，使用以下命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netsat -a --numeric-ports</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> netsat -a --numeric-hosts</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> netsat -a --numeric-users</span></span><br></pre></td></tr></table></figure>

<h2 id="6-显示核心路由信息-netstat-r"><a href="#6-显示核心路由信息-netstat-r" class="headerlink" title="6. 显示核心路由信息 netstat -r"></a>6. 显示核心路由信息 netstat -r</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -r</span></span><br><span class="line"> Kernel IP routing table</span><br><span class="line"> Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line"> 192.168.1.0     *               255.255.255.0   U         0 0          0 eth2</span><br><span class="line"> link-local      *               255.255.0.0     U         0 0          0 eth2</span><br><span class="line"> default         192.168.1.1     0.0.0.0         UG        0 0          0 eth2</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 使用 netstat -rn 显示数字格式，不查询主机名称。</p>
<h2 id="7-找出程序运行的端口"><a href="#7-找出程序运行的端口" class="headerlink" title="7. 找出程序运行的端口"></a>7. 找出程序运行的端口</h2><p>并不是所有的进程都能找到，没有权限的会不显示，使用 root 权限查看所有的信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -ap | grep ssh</span></span><br><span class="line"> tcp        1      0 dev-db:ssh           101.174.100.22:39213        CLOSE_WAIT  -</span><br><span class="line"> tcp        1      0 dev-db:ssh           101.174.100.22:57643        CLOSE_WAIT  -</span><br></pre></td></tr></table></figure>

<p> <strong>找出运行在指定端口的进程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># netstat -an | grep &#x27;:80&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="8-显示网络接口列表"><a href="#8-显示网络接口列表" class="headerlink" title="8. 显示网络接口列表"></a>8. 显示网络接口列表</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -i</span></span><br><span class="line"> Kernel Interface table</span><br><span class="line"> Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line"> eth0       1500 0         0      0      0 0             0      0      0      0 BMU</span><br><span class="line"> eth2       1500 0     26196      0      0 0         26883      6      0      0 BMRU</span><br><span class="line"> lo        16436 0         4      0      0 0             4      0      0      0 LRU</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先把状态全都取出来,然后使用uniq -c统计，之后再进行排序。</span><br></pre></td></tr></table></figure>



<p>分析状态个数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wss8848@ubuntu:~$ netstat -nat |awk &#x27;&#123;print $6&#125;&#x27;|sort|uniq -c</span><br><span class="line">143 ESTABLISHED</span><br><span class="line">1 FIN_WAIT1</span><br><span class="line">1 Foreign</span><br><span class="line">1 LAST_ACK</span><br><span class="line">36 LISTEN</span><br><span class="line">6 SYN_SENT</span><br><span class="line">113 TIME_WAIT</span><br><span class="line">1 established)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/27/blog/tcp-ip-socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/27/blog/tcp-ip-socket/" class="post-title-link" itemprop="url">TCP-IP SOCKET</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-27 10:42:23 / Modified: 10:41:20" itemprop="dateCreated datePublished" datetime="2022-01-27T10:42:23+08:00">2022-01-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。</p>
<p>*UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。<br>这里有一张图，表明了这些协议的关系。<br><img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/20180913104811138" alt="tcp-ip 4层"><br>TCP/IP协议族包括运输层、网络层、链路层。现在你知道TCP/IP与UDP的关系了吧。<br>Socket在哪里呢？<br>在图1中，我们没有看到Socket的影子，那么它到底在哪里呢？还是用图来说话，一目了然。<br><img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/2018091310482621" alt="socket在哪里"></p>
<p><strong>Socket是应用层与TCP/IP协议族通信的中间软件抽象层</strong>，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。<br>你会使用它们吗？<br>前人已经给我们做了好多的事了，网络间的通信也就简单了许多，但毕竟还是有挺多工作要做的。以前听到Socket编程，觉得它是比较高深的编程知识，但是只要弄清Socket编程的工作原理，神秘的面纱也就揭开了。<br>一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景就解释了这工作原理，也许TCP/IP协议族就是诞生于生活中，这也不一定。<br><img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/20180913104844708" alt="tcp交互">*</p>
<p>先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/26/blog/linux-ss/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/26/blog/linux-ss/" class="post-title-link" itemprop="url">linux ss 命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-26 15:42:23" itemprop="dateCreated datePublished" datetime="2022-01-26T15:42:23+08:00">2022-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-27 15:39:54" itemprop="dateModified" datetime="2022-01-27T15:39:54+08:00">2022-01-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>ss</strong></p>
<p>用来显示处于活动状态的套接字信息。ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。但ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。</p>
<p>当服务器的socket连接数量变得非常大时，无论是使用netstat命令还是直接cat<code>/proc/net/tcp</code>，执行速度都会很慢。可能你不会有切身的感受，但请相信我，当服务器维持的连接达到上万个的时候，使用netstat等于浪费 生命，而用ss才是节省时间。</p>
<p>天下武功唯快不破。ss快的秘诀在于，它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。当然，如果你的系统中没有tcp_diag，ss也可以正常运行，只是效率会变得稍慢。</p>
<p><strong>选项</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-h：显示帮助信息；</span><br><span class="line">-V：显示指令版本信息；</span><br><span class="line">-n：不解析服务名称，以数字方式显示；</span><br><span class="line">-a：显示所有的套接字；</span><br><span class="line">-l：显示处于监听状态的套接字；</span><br><span class="line">-o：显示计时器信息；</span><br><span class="line">-m：显示套接字的内存使用情况；</span><br><span class="line">-p：显示使用套接字的进程信息；</span><br><span class="line">-i：显示内部的TCP信息；</span><br><span class="line">-4：只显示ipv4的套接字；</span><br><span class="line">-6：只显示ipv6的套接字；</span><br><span class="line">-t：只显示tcp套接字；</span><br><span class="line">-u：只显示udp套接字；</span><br><span class="line">-d：只显示DCCP套接字；</span><br><span class="line">-w：仅显示RAW套接字；</span><br><span class="line">-x：仅显示UNIX域套接字。</span><br></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<p><strong>显示TCP连接</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ss -t -a</span><br><span class="line">State       Recv-Q Send-Q                            Local Address:Port                                Peer Address:Port   </span><br><span class="line">LISTEN      0      0                                             *:3306                                           *:*       </span><br><span class="line">LISTEN      0      0                                             *:http                                           *:*       </span><br><span class="line">LISTEN      0      0                                             *:ssh                                            *:*       </span><br><span class="line">LISTEN      0      0                                     127.0.0.1:smtp                                           *:*       </span><br><span class="line">ESTAB       0      0                                112.124.15.130:42071                              42.156.166.25:http    </span><br><span class="line">ESTAB       0      0                                112.124.15.130:ssh                              121.229.196.235:33398 </span><br></pre></td></tr></table></figure>

<p><strong>显示 Sockets 摘要</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ss -s</span><br><span class="line">Total: 172 (kernel 189)</span><br><span class="line">TCP:   10 (estab 2, closed 4, orphaned 0, synrecv 0, timewait 0/0), ports 5</span><br><span class="line"></span><br><span class="line">Transport Total     ip        IPv6</span><br><span class="line">*         189       -         -        </span><br><span class="line">RAW       0         0         0        </span><br><span class="line">UDP       5         5         0        </span><br><span class="line">TCP       6         6         0        </span><br><span class="line">INET      11        11        0        </span><br><span class="line">FRAG      0         0         0   </span><br></pre></td></tr></table></figure>

<p>列出当前的established, closed, orphaned and waiting TCP sockets</p>
<p><strong>查看进程使用的socket</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ss -pl</span><br><span class="line">State       Recv-Q Send-Q                                Local Address:Port                                    Peer Address:Port   </span><br><span class="line">LISTEN      0      128                                              :::ssh                                               :::*        users:((&quot;sshd&quot;,1292,4))</span><br><span class="line">LISTEN      0      128                                               *:ssh                                                *:*        users:((&quot;sshd&quot;,1292,3))</span><br><span class="line">LISTEN      0      128                                       127.0.0.1:ipp                                                *:*        users:((&quot;cupsd&quot;,1165,7))</span><br><span class="line">LISTEN      0      128                                             ::1:ipp                                               :::*        users:((&quot;cupsd&quot;,1165,6))</span><br><span class="line">LISTEN      0      128                                               *:32957                                              *:*        users:((&quot;rpc.statd&quot;,1104,9))</span><br><span class="line">LISTEN      0      128                                              :::57637                                             :::*        users:((&quot;rpc.statd&quot;,1104,11))</span><br><span class="line">LISTEN      0      80                                               :::mysql                                             :::*        users:((&quot;mysqld&quot;,1528,17))</span><br><span class="line">LISTEN      0      128                                               *:6379                                               *:*        users:((&quot;redis-server&quot;,1672,5))</span><br><span class="line">LISTEN      0      128                                              :::6379                                              :::*        users:((&quot;redis-server&quot;,1672,4))</span><br><span class="line">LISTEN      0      128                                              :::sunrpc                                            :::*        users:((&quot;rpcbind&quot;,1084,11))</span><br><span class="line">LISTEN      0      128                                               *:sunrpc                                             *:*        users:((&quot;rpcbind&quot;,1084,8))</span><br><span class="line">LISTEN      0      128                                               *:http                                               *:*        users:((&quot;nginx&quot;,1685,13),(&quot;nginx&quot;,3698,13),(&quot;nginx&quot;,3699,13))</span><br></pre></td></tr></table></figure>


<p><strong>找出打开套接字/端口应用程序</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ss -pl | grep 3306</span><br><span class="line">0      0                            *:3306                          *:*        users:((&quot;mysqld&quot;,1718,10))</span><br></pre></td></tr></table></figure>

<p><strong>关于Recv-Q和Send-Q状态</strong>- es</p>
<p><strong>recv-Q 表示网络接收队列</strong><br><strong>表示收到的数据已经在本地接收缓冲，但是还有多少没有被进程取走，recv()</strong><br>如果接收队列Recv-Q一直处于阻塞状态，可能是遭受了拒绝服务 denial-of-service 攻击。</p>
<p>s<strong>end-Q 表示网路发送队列</strong><br><strong>对方没有收到的数据或者说没有Ack的,还是本地缓冲区.</strong><br>如果发送队列Send-Q不能很快的清零，可能是有应用向外发送数据包过快，或者是对方接收数据包不够快。</p>
<p>这两个值通常应该为0，如果不为0可能是有问题的。packets在两个队列里都不应该有堆积状态。可接受短暂的非0情况。</p>
<p>对于上边的说法不能说错，但最起码不完全正确，我感觉下边的才是正解，来自：<a target="_blank" rel="noopener" href="http://jaseywang.me/2014/07/20/tcp-queue-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/">TCP queue 的一些问题</a> </p>
<ol>
<li> 当 client 通过 connect 向 server 发出 SYN 包时，client 会维护一个 socket 等待队列，而 server 会维护一个 SYN 队列</li>
<li> 此时进入半链接的状态，如果 socket 等待队列满了，server 则会丢弃，而 client 也会由此返回 connection time out；只要是 client 没有收到 SYN+ACK，3s 之后，client 会再次发送，如果依然没有收到，9s 之后会继续发送</li>
<li> 半连接 syn 队列的长度为 max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog) 决定</li>
<li> 当 server 收到 client 的 SYN 包后，会返回 SYN, ACK 的包加以确认，client 的 TCP 协议栈会唤醒 socket 等待队列，发出 connect 调用</li>
<li> client 返回 ACK 的包后，server 会进入一个新的叫 accept 的队列，该队列的长度为 min(backlog, somaxconn)，默认情况下，somaxconn 的值为 128，表示最多有 129 的 ESTAB 的连接等待 accept()，而 backlog 的值则由 <a target="_blank" rel="noopener" href="http://http//linux.die.net/man/2/listen">int listen(int sockfd, int backlog)</a> 中的第二个参数指定，listen 里面的 backlog 的含义请看这里。需要注意的是，<a target="_blank" rel="noopener" href="http://serverfault.com/questions/518862/testifying-rasing-net-core-somaxconn-can-make-a-difference">一些 Linux 的发型版本可能存在对 somaxcon 错误 truncating 方式</a>。</li>
<li>当 accept 队列满了之后，即使 client 继续向 server 发送 ACK 的包，也会不被响应，此时，server 通过 /proc/sys/net/ipv4/tcp_abort_on_overflow 来决定如何返回，0 表示直接丢丢弃该 ACK，1 表示发送 RST 通知 client；相应的，client 则会分别返回 read timeout 或者 connection reset by peer。上面说的只是些理论，如果服务器不及时的调用 accept()，当 queue 满了之后，服务器并不会按照理论所述，不再对 SYN 进行应答，返回 ETIMEDOUT。根据<a target="_blank" rel="noopener" href="http://www.douban.com/note/178129553/">这篇</a>文档的描述，实际情况并非如此，服务器会随机的忽略收到的 SYN，建立起来的连接数可以无限的增加，只不过客户端会遇到延时以及超时的情况。</li>
</ol>
<p>注意，<a target="_blank" rel="noopener" href="http://jaseywang.me/2012/10/12/netstat-%E4%B8%AD%E7%9A%84-recvsend/">之前我对 Recv-Q/Send-Q 的理解有些误差</a>，使用 ss 获取到的 Recv-Q/Send-Q 在 LISTEN 状态以及非 LISTEN 状态所表达的含义是不同的。从 <a target="_blank" rel="noopener" href="http://www.cs.fsu.edu/~baker/devices/lxr/http/source/linux/net/ipv4/tcp_diag.c?v=2.6.25">tcp_diag.c 源码</a>中可以看到二者的区别:</p>
<p><strong>LISTEN 状态: Recv-Q 表示的当前等待服务端调用 accept 完成三次握手的 listen backlog 数值，也就是说，当客户端通过 connect() 去连接正在 listen() 的服务端时，这些连接会一直处于这个 queue 里面直到被服务端 accept()；Send-Q 表示的则是最大的 listen backlog 数值，这就就是上面提到的 min(backlog, somaxconn) 的值。</strong><br><strong>其余状态: 非 LISTEN 状态之前理解的没有问题。Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/26/blog/linux%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/26/blog/linux%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">linux性能工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-26 15:42:23" itemprop="dateCreated datePublished" datetime="2022-01-26T15:42:23+08:00">2022-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-27 11:39:24" itemprop="dateModified" datetime="2022-01-27T11:39:24+08:00">2022-01-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>每次发现系统变慢时，我们通常做的第一件事，就是执行 <code>top</code> 或者 <code>uptime</code> 命令，来了解系统的负载情况。<br>比如像下面这样，我在命令行里输入了 <code>uptime</code> 命令，系统也随即给出了结果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@10.20.12.9~]# uptime</span><br><span class="line"> 15:44:15 up 27 days, 17:25,  2 users,  load average: 6.69, 6.62, 5.52</span><br></pre></td></tr></table></figure>
<p>但我想问的是，你真的知道这里每列输出的含义吗？<br>我相信你对前面的几列比较熟悉，它们分别是当前时间、系统运行时间以及正在登录用户数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">02:34:03 //当前时间</span><br><span class="line">up 2 days, 20:14 //系统运行时间</span><br><span class="line">1 user //正在登录用户数</span><br></pre></td></tr></table></figure>
<p>而最后三个数字呢，依次则是过去 1 分钟、5 分钟、15 分钟的平均负载（Load Average）。</p>
<p>简单来说，<strong>平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数</strong>，它和 CPU 使用率并没有直接关系。</p>
<p>这里我先解释下，可运行状态和不可中断状态这俩词儿。</p>
<p>所谓<strong>可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程</strong>，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。</p>
<p><strong>不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的</strong>，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。</p>
<h3 id="平均负载为多少时合理"><a href="#平均负载为多少时合理" class="headerlink" title="平均负载为多少时合理"></a>平均负载为多少时合理</h3><p>平均负载最理想的情况是等于 CPU 个数。所以在评判平均负载时，首先你要知道系统有几个 CPU，这可以通过 top 命令或者从文件 /proc/cpuinfo 中读取</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@10.20.12.9~]# cat /proc/cpuinfo  | grep &#x27;model name&#x27; | wc -l</span><br><span class="line">32</span><br></pre></td></tr></table></figure>

<p>三个都要看</p>
<ul>
<li>  如果 1 分钟、5 分钟、15 分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。</li>
<li>  但如果 1 分钟的值远小于 15 分钟的值，就说明系统最近 1 分钟的负载在减少，而过去 15 分钟内却有很大的负载。</li>
<li>  反过来，如果 1 分钟的值远大于 15 分钟的值，就说明最近 1 分钟的负载在增加，这种增加有可能只是临时性的，也有可能还会持续增加下去，所以就需要持续观察。一旦 1 分钟的平均负载接近或超过了 CPU 的个数，就意味着系统正在发生过载的问题，这时就得分析调查是哪里导致的问题，并要想办法优化了。</li>
</ul>
<p>这里我再举个例子，假设我们在一个单 CPU 系统上看到平均负载为 1.73，0.60，7.98，那么说明在过去 1 分钟内，系统有 73% 的超载，而在 15 分钟内，有 698% 的超载，从整体趋势来看，系统的负载在降低。</p>
<p><strong>当平均负载高于 CPU 数量 70% 的时候</strong>，你就应该分析排查负载高的问题了。</p>
<h2 id="mpstat"><a href="#mpstat" class="headerlink" title="mpstat"></a>mpstat</h2><p>mpstat是Multiprocessor Statistics的缩写，是实时系统监控工具。其报告与CPU的一些统计信息，这些信息存放在/proc/stat文件中。在多CPUs系统里，其不但能查看所有CPU的平均状况信息，而且能够查看特定CPU的信息。mpstat最大的特点是：可以查看多核心cpu中每个计算核心的统计数据；而类似工具vmstat只能查看系统整体cpu情况。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mpstat [-P &#123;|ALL&#125;] [internal [count]]</span><br><span class="line">参数 解释</span><br><span class="line">-P &#123;|ALL&#125; 表示监控哪个CPU， cpu在[0,cpu个数-1]中取值</span><br><span class="line">internal 相邻的两次采样的间隔时间、</span><br><span class="line">count 采样的次数，count只能和delay一起使用</span><br><span class="line">当没有参数时，mpstat则显示系统启动以后所有信息的平均值。有interval时，第一行的信息自系统启动以来的平均信息。从第二行开始，输出为前一个interval时间段的平均信息。</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mpstat -P ALL 5</span></span><br><span class="line">Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU)</span><br><span class="line">13:30:06     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">13:30:11     all   50.05    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   49.95</span><br><span class="line">13:30:11       0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">13:30:11       1  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%user      在internal时间段里，用户态的CPU时间(%)，不包含nice值为负进程  (usr/total)*100</span><br><span class="line">%nice      在internal时间段里，nice值为负进程的CPU时间(%)   (nice/total)*100</span><br><span class="line">%sys       在internal时间段里，内核时间(%)       (system/total)*100</span><br><span class="line">%iowait    在internal时间段里，硬盘IO等待时间(%) (iowait/total)*100</span><br><span class="line">%irq       在internal时间段里，硬中断时间(%)     (irq/total)*100</span><br><span class="line">%soft      在internal时间段里，软中断时间(%)     (softirq/total)*100</span><br><span class="line">%idle      在internal时间段里，CPU除去等待磁盘IO操作外的因为任何原因而空闲的时间闲置时间(%) (idle/total)*100</span><br></pre></td></tr></table></figure>



<h2 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h2><p>pidstat是sysstat工具的一个命令，用于监控全部或指定进程的cpu、内存、线程、设备IO等系统资源的占用情况。pidstat首次运行时显示自系统启动开始的各项统计信息，之后运行pidstat将显示自上次运行该命令以后的统计信息。用户可以通过指定统计的次数和时间来获得所需的统计信息。</p>
<h2 id="pidstat-示例"><a href="#pidstat-示例" class="headerlink" title="pidstat 示例"></a>pidstat 示例</h2><p>pidstat 的用法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat <span class="selector-attr">[ 选项 ]</span> <span class="selector-attr">[ &lt;时间间隔&gt; ]</span> <span class="selector-attr">[ &lt;次数&gt; ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">常用的参数：</span><br><span class="line"></span><br><span class="line">-u：默认的参数，显示各个进程的cpu使用统计</span><br><span class="line">-r：显示各个进程的内存使用统计</span><br><span class="line">-d：显示各个进程的IO使用情况</span><br><span class="line">-p：指定进程号</span><br><span class="line">-w：显示每个进程的上下文切换情况</span><br><span class="line">-t：显示选择任务的线程的统计信息外的额外信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例</p>
<ol>
<li> 查看所有进程的 CPU 使用情况（ -u -p ALL）</li>
<li> cpu使用情况统计(-u)</li>
<li> 内存使用情况统计(-r)</li>
<li> 显示各个进程的IO使用情况（-d）</li>
<li> 显示每个进程的上下文切换情况（-w）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 间隔5秒后输出一组数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pidstat -u 5 1</span></span><br><span class="line">13:37:07      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">13:37:12        0      2962  100.00    0.00    0.00    0.00  100.00     1  stress</span><br></pre></td></tr></table></figure>

<h2 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h2><p>第一种常见用法是 perf top，类似于 top，它能够实时显示占用 CPU 时钟最多的函数或者指令，因此可以用来查找热点函数，使用界面如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> perf top</span></span><br><span class="line">Samples: 833  of event &#x27;cpu-clock&#x27;, Event count (approx.): 97742399</span><br><span class="line">Overhead  Shared Object       Symbol</span><br><span class="line">   7.28%  perf                [.] 0x00000000001f78a4</span><br><span class="line">   4.72%  [kernel]            [k] vsnprintf</span><br><span class="line">   4.32%  [kernel]            [k] module_get_kallsym</span><br><span class="line">   3.65%  [kernel]            [k] _raw_spin_unlock_irqrestore</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>输出结果中，第一行包含三个数据，分别是采样数（Samples）、事件类型（event）和事件总数量（Event count）。比如这个例子中，perf 总共采集了 833 个 CPU 时钟事件，而总事件数则为 97742399。</p>
<p>再往下看是一个表格式样的数据，每一行包含四列，分别是：</p>
<ul>
<li>  第一列 Overhead ，是该符号的性能事件在所有采样中的比例，用百分比来表示。</li>
<li>  第二列 Shared ，是该函数或指令所在的动态共享对象（Dynamic Shared Object），如内核、进程名、动态链接库名、内核模块名等。</li>
<li>  第三列 Object ，是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间。</li>
<li>  最后一列 Symbol 是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示。</li>
</ul>
<p>接着再来看第二种常见用法，也就是 perf record 和 perf report。 perf top 虽然实时展示了系统的性能信息，但它的缺点是并不保存数据，也就无法用于离线或者后续的分析。而 perf record 则提供了保存数据的功能，保存后的数据，需要你用 perf report 解析展示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ perf record # 按Ctrl+C终止采样</span><br><span class="line">[ perf record: Woken up 1 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 0.452 MB perf.data (6093 samples) ]</span><br><span class="line"></span><br><span class="line">$ perf report # 展示类似于perf top的报告</span><br></pre></td></tr></table></figure>

<p>CPU周期(cpu-cycles)是默认的性能事件<br>比如我们上面的命令<code>perf record  -p 4221</code>实际上是<code>perf record -e cpu-clock -p 4221</code>的简写形式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> perf record -F 99 -p 13204 -g -- sleep 30</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> perf report -n --stdio</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/26/blog/tcp-closewait/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/26/blog/tcp-closewait/" class="post-title-link" itemprop="url">TCP CLOSE_WAIT 太多问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-26 15:42:23" itemprop="dateCreated datePublished" datetime="2022-01-26T15:42:23+08:00">2022-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-27 15:10:24" itemprop="dateModified" datetime="2022-01-27T15:10:24+08:00">2022-01-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p>我们来看看 <strong>TCP</strong> 的四次挥手是怎么样的流程：</p>
<img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/167928e06180fc5e%7Etplv-t2oaga2asx-watermark.awebp" alt="image-20181208175427046" style="zoom: 50%;" />



<p><strong>图五：TCP四次挥手</strong></p>
<p>用中文来描述下这个过程：</p>
<p>Client: <code>服务端大哥，我事情都干完了，准备撤了</code>，这里对应的就是客户端发了一个<strong>FIN</strong></p>
<p>Server：<code>知道了，但是你等等我，我还要收收尾</code>，这里对应的就是服务端收到 <strong>FIN</strong> 后回应的 <strong>ACK</strong></p>
<p>经过上面两步之后，服务端就会处于 <strong>CLOSE_WAIT</strong> 状态。过了一段时间 <strong>Server</strong> 收尾完了</p>
<p>Server：<code>小弟，哥哥我做完了，撤吧</code>，服务端发送了<strong>FIN</strong></p>
<p>Client：<code>大哥，再见啊</code>，这里是客户端对服务端的一个 <strong>ACK</strong></p>
<p>到此服务端就可以跑路了，但是客户端还不行。为什么呢？客户端还必须等待 <strong>2MSL</strong> 个时间，这里为什么客户端还不能直接跑路呢？主要是为了防止发送出去的 <strong>ACK</strong> 服务端没有收到，服务端重发 <strong>FIN</strong> 再次来询问，如果客户端发完就跑路了，那么服务端重发的时候就没人理他了。这个等待的时间长度也很讲究。</p>
<p><u><strong>Maximum Segment Lifetime</strong> 报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃</u></p>
<p>这里一定不要被图里的 <strong>client／server</strong> 和项目里的客户端服务器端混淆，你只要记住：主动关闭的一方发出 <strong>FIN</strong> 包（Client），被动关闭（Server）的一方响应 <strong>ACK</strong> 包，此时，被动关闭的一方就进入了 <strong>CLOSE_WAIT</strong> 状态。如果一切正常，稍后被动关闭的一方也会发出 <strong>FIN</strong> 包，然后迁移到 <strong>LAST_ACK</strong> 状态。</p>
<p>既然是这样， <strong>TCP</strong> 抓包分析下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/go # tcpdump -n port 3306</span><br><span class="line"># 发生了 3次握手</span><br><span class="line">11:38:15.679863 IP 172.18.0.5.38822 &gt; 172.18.0.3.3306: Flags [S], seq 4065722321, win 29200, options [mss 1460,sackOK,TS val 2997352 ecr 0,nop,wscale 7], length 0</span><br><span class="line">11:38:15.679923 IP 172.18.0.3.3306 &gt; 172.18.0.5.38822: Flags [S.], seq 780487619, ack 4065722322, win 28960, options [mss 1460,sackOK,TS val 2997352 ecr 2997352,nop,wscale 7], length 0</span><br><span class="line">11:38:15.679936 IP 172.18.0.5.38822 &gt; 172.18.0.3.3306: Flags [.], ack 1, win 229, options [nop,nop,TS val 2997352 ecr 2997352], length 0</span><br><span class="line"></span><br><span class="line"># mysql 主动断开链接</span><br><span class="line">11:38:45.693382 IP 172.18.0.3.3306 &gt; 172.18.0.5.38822: Flags [F.], seq 123, ack 144, win 227, options [nop,nop,TS val 3000355 ecr 2997359], length 0 # MySQL负载均衡器发送fin包给我</span><br><span class="line">11:38:45.740958 IP 172.18.0.5.38822 &gt; 172.18.0.3.3306: Flags [.], ack 124, win 229, options [nop,nop,TS val 3000360 ecr 3000355], length 0 # 我回复ack给它</span><br><span class="line"></span><br><span class="line">... ... # 本来还需要我发送fin给他，但是我没有发，所以出现了close_wait。那这是什么缘故呢？</span><br></pre></td></tr></table></figure>

<p>结合上面的信息，我用文字说明下：<strong>MySQL负载均衡器</strong> 给我的服务发送 <strong>FIN</strong> 包，我进行了响应，此时我进入了 <strong>CLOSE_WAIT</strong> 状态，但是后续作为被动关闭方的我，并没有发送 <strong>FIN</strong>，导致我服务端一直处于 <strong>CLOSE_WAIT</strong> 状态，无法最终进入 <strong>CLOSED</strong> 状态。</p>
<ul>
<li>  <strong>大量<code>CLOSE_WAIT</code>有什么危害?</strong> <code>CLOSE_WAIT</code>状态不会自己消失,除非对应的应用进程死掉,不会消失就意味着一直占用服务器资源,端口总数又只有65535,因此这里的服务器作为连接的发起者就会造成大量端口被占用,一旦占用完就导致后面的请求都发不出去,也就是一开始图上另一个项目发请求出现的<code>Address already in use (Bind failed)</code>错误.</li>
<li>被动方什么情况下<code>FIN</code>包会发送失败?<ul>
<li>  <strong>程序问题</strong>：如果代码层面忘记了 close 相应的 socket 连接，那么自然不会发出 FIN 包，从而导致 CLOSE_WAIT 累积；或者代码不严谨，出现死循环之类的问题，导致即便后面写了 close 也永远执行不到。</li>
<li>  <strong>响应太慢或者超时设置过小</strong>：如果连接双方不和谐，一方不耐烦直接 timeout，另一方却还在忙于耗时逻辑，就会导致 close 被延后。响应太慢是首要问题，不过换个角度看，也可能是 timeout 设置过小。</li>
<li>  BACKLOG 太大：此处的 backlog 不是 syn backlog，而是 accept 的 backlog，如果 backlog 太大的话，设想突然遭遇大访问量的话，即便响应速度不慢，也可能出现来不及消费的情况，导致多余的请求还在队列里就被对方关闭了。</li>
</ul>
</li>
</ul>
<p>如果你通过「netstat -ant」或者「ss -ant」命令发现了很多 CLOSE_WAIT 连接，请注意结果中的「Recv-Q」和「Local Address」字段，通常「Recv-Q」会不为空，它表示应用还没来得及接收数据，而「Local Address」表示哪个地址和端口有问题，我们可以通过「lsof -i:<PORT>」来确认端口对应运行的是什么程序以及它的进程号是多少。</p>
<p>如果是我们自己写的一些程序，比如用 HttpClient 自定义的蜘蛛，那么八九不离十是程序问题，如果是一些使用广泛的程序，比如 Tomcat 之类的，那么更可能是响应速度太慢或者 timeout 设置太小或者 BACKLOG 设置过大导致的故障。</p>
<p>此外还有一点需要说明：按照前面图例所示，当被动关闭的一方处于 CLOSE_WAIT 状态时，主动关闭的一方处于 FIN_WAIT2 状态。 那么为什么我们总听说 CLOSE_WAIT 状态过多的故障，但是却相对少听说 FIN_WAIT2 状态过多的故障呢？这是因为 Linux 有一个「tcp_fin_timeout」设置，控制了 FIN_WAIT2 的最大生命周期。坏消息是 CLOSE_WAIT 没有类似的设置，如果不重启进程，那么 CLOSE_WAIT 状态很可能会永远持续下去；好消息是如果 socket 开启了 <a target="_blank" rel="noopener" href="http://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/">keepalive</a> 机制，那么可以通过相应的设置来清理无效连接，不过 keepalive 是治标不治本的方法，还是应该找到问题的症结才对。</p>
<p>本来想多写点的，但是着急回家，就写到这吧，推荐两个案例：</p>
<ul>
<li>  <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MjM5NzUwNDA5MA==&mid=200667929&idx=1&sn=67cada895ac100115fded319b6b23a21&3rd=MzA3MDU4NTYzMw==&scene=6#rd">PHP升级导致系统负载过高问题分析</a></li>
<li>  <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI4MjA4ODU0Ng==&mid=402163560&idx=1&sn=5269044286ce1d142cca1b5fed3efab1&3rd=MzA3MDU4NTYzMw==&scene=6#rd">又见CLOSE_WAIT</a></li>
</ul>
<p>写得都比我好，建议大家仔细阅读。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/25/blog/go-ldflags/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/25/blog/go-ldflags/" class="post-title-link" itemprop="url">golang ldflags</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-25 15:42:23 / Modified: 16:49:55" itemprop="dateCreated datePublished" datetime="2022-01-25T15:42:23+08:00">2022-01-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.digitalocean.com/community/tutorials/using-ldflags-to-set-version-information-for-go-applications">Using <code>ldflags</code> with <code>go build</code></a></p>
<p><code>ld</code> stands for linker, the program that links together the different pieces of the compiled source code into the final binary.</p>
<p><code>ldflags</code>, stands for linker flags. It passes a flag to the underlying Go toolchain linker, <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://golang.org/cmd/link">cmd/link</a>, that allows you to change the values of imported packages at build time from the command line.</p>
<p>使用方式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line">go build -ldflags=<span class="string">&quot;-flag&quot;</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">go build -ldflags=<span class="string">&quot;-X &#x27;package_path.variable_name=new_value&#x27;&quot;</span></span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">go build -ldflags=<span class="string">&quot;-X &#x27;main.Version=v1.0.0&#x27;&quot;</span></span><br><span class="line"><span class="comment">#复杂实例</span></span><br><span class="line">go build -v -ldflags=<span class="string">&quot;-X &#x27;main.Version=v1.0.0&#x27; -X &#x27;app/build.User=<span class="subst">$(id -u -n)</span>&#x27; -X &#x27;app/build.Time=<span class="subst">$(date)</span>&#x27;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><ul>
<li>  <strong>外层使用双引号，确保传递的flag中的内容即使包含空格也不截断命令；</strong></li>
<li>  <strong>key-value值使用单引号</strong></li>
<li>  <strong>要改变的变量需要是包级别的string类型变量。不能是const类型</strong></li>
<li>  <strong>变量是否export都可以（大小写开头的变量都支持）</strong></li>
</ul>
<p>在make文件main.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	version   <span class="keyword">string</span></span><br><span class="line">	date      <span class="keyword">string</span></span><br><span class="line">	goversion <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> version == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		version = <span class="string">&quot;no version&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> date == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		date = <span class="string">&quot;(Mon YYYY)&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> goversion == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		goversion = <span class="string">&quot;no go version&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(version, date, goversion)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">version=0.0.1</span><br><span class="line">d=`date <span class="string">&quot;+(%b %Y)&quot;</span>`</span><br><span class="line"><span class="built_in">exec</span>=a.out</span><br><span class="line"></span><br><span class="line">.PHONY: all</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;version&#125;</span>&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;d&#125;</span>&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot; make &lt;cmd&gt;&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;commands:&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot; build          - runs go build&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot; build_version  - runs go build with ldflags version=<span class="variable">$&#123;version&#125;</span> &amp; date=<span class="variable">$&#123;d&#125;</span>&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">build: clean</span><br><span class="line">	@go build -v -o <span class="variable">$&#123;exec&#125;</span></span><br><span class="line"></span><br><span class="line">build_version: check_version </span><br><span class="line">	@go build -v -ldflags <span class="string">&quot;-X &#x27;main.version=<span class="variable">$&#123;version&#125;</span>&#x27; -X &#x27;main.date=<span class="variable">$&#123;d&#125;</span>&#x27; -X &#x27;main.goversion=<span class="subst">$(shell go version)</span>&#x27;&quot;</span> -o <span class="variable">$&#123;exec&#125;</span>_<span class="variable">$&#123;version&#125;</span></span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	@rm -f <span class="variable">$&#123;exec&#125;</span></span><br><span class="line">	@rm -f <span class="variable">$&#123;exec&#125;</span>_<span class="variable">$&#123;version&#125;</span></span><br><span class="line"></span><br><span class="line">check_version:</span><br><span class="line">	@<span class="keyword">if</span> [ -a <span class="string">&quot;<span class="variable">$&#123;exec&#125;</span>_<span class="variable">$&#123;version&#125;</span>&quot;</span> ]; <span class="keyword">then</span> \</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;exec&#125;</span>_<span class="variable">$&#123;version&#125;</span> already exists&quot;</span>; \</span><br><span class="line">		rm -f <span class="variable">$&#123;exec&#125;</span>_<span class="variable">$&#123;version&#125;</span>; \</span><br><span class="line">	 <span class="keyword">fi</span>;</span><br></pre></td></tr></table></figure>

<p>Makefile</p>
<p>1、行首以tab 开头，否则报错Makefile:8: *** missing separator. Stop.</p>
<p>2、d=<code>date &quot;+(%b %Y)&quot;</code> 或 d=$(shell date “+(%b %Y)”)</p>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://blog.cloudflare.com/setting-go-variables-at-compile-time/">Setting Go variables from the outside</a></p>
<p>在<code>go run</code>命令中也可以直接使用（因为会默认先执行<code>go build</code>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run -ldflags=&quot;-X main.who CloudFlare&quot; hello.go</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/24/blog/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/blog/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">go map实现底层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-24 20:50:31 / Modified: 20:00:18" itemprop="dateCreated datePublished" datetime="2022-01-24T20:50:31+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>map</strong> 其实可以理解为一种<strong>哈希表</strong>数据结构。几乎所有的编程语言都会有数组和哈希表这两种数据结构，有的编程语言将数组称为列表，比如：Python，而有的语言将 map 称作字典或者映射。无论如何命名或者如何实现，数组和哈希是两种设计集合元素的思路，数组用于表示元素的序列，而哈希表示的是键值对之间映射关系。</p>
<p>以下哈希表即为<strong>Map</strong>。</p>
<h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>哈希表是计算机中最重要的数据结构之一，不仅是因为它 𝑂(1) 的时间复杂度，而且读写性能非常好，它还提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点：</p>
<ul>
<li>  哈希函数的选择</li>
<li>  哈希冲突的解决</li>
</ul>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>实现哈希表的关键点在于哈希函数的选择，哈希函数的选择在很大程度上能够决定哈希表的读写性能。</p>
<p>实际的方式是让哈希函数的结果能够尽可能的均匀分布，然后通过相应的方法来解决哈希冲突的问题。哈希函数映射的结果一定要尽可能均匀，结果不均匀的哈希函数会带来更多的哈希冲突以及更差的读写性能。</p>
<p>如果使用结果分布较为均匀的哈希函数，那么哈希的增删改查的时间复杂度为 𝑂(1)；但是如果哈希函数的结果分布不均匀，那么所有操作的时间复杂度可能会达到 𝑂(𝑛)，由此看来，选择使用好的哈希函数是至关重要的。</p>
<h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><p>前面所提到的，在通常情况下，哈希函数是不一定完美的，当输入的键足够多也会产生冲突，所以仍然存在发生哈希碰撞的可能，这时就需要一些方法来解决哈希碰撞的问题，常见方法的有：<strong>开放寻址法</strong>和<strong>拉链法</strong>。</p>
<h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p><strong>开放寻址法</strong>是一种在哈希表中解决哈希碰撞的比较普通的方法，这种方法的核心思想是：<strong>依次探测和比较数组中的元素以判断目标键值对是否存在于哈希表中</strong>，如果我们使用开放寻址法来实现哈希表，那么实现哈希表底层的数据结构就是数组，不过因为数组的长度有限。</p>
<p>当我们向当前哈希表写入新的数据时，如果发生了冲突，就会将键值对写入到下一个索引不为空的位置，如下：</p>
<p><img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/2066f1668cd34ff8b6a477320452c0a7%7Etplv-k3u1fbpfcp-watermark.image" alt="开放寻址法.png"></p>
<p>如上图所示，当 Key3 与已经存入哈希表中的两个键值对 Key1 和 Key2 发生冲突时，Key3 会被写入 Key2 后面的空闲位置。当我们再去读取 Key3 对应的值时就会先获取键的哈希并取模，这会先帮助我们找到 Key1，找到 Key1 后发现它与 Key 3 不相等，所以会继续查找后面的元素，直到内存为空或者找到目标元素。</p>
<p><img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/78c696b156104081a3ffbdd43a1584f7%7Etplv-k3u1fbpfcp-watermark.image" alt="开放寻址法2.png"></p>
<p>开放寻址法中对性能影响最大的是<strong>装载因子</strong>，它是数组中元素的数量与数组大小的比值。随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会影响哈希表的读写性能。当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 𝑂(𝑛) 的，这时需要遍历数组中的全部元素，所以在实现哈希表时一定要关注装载因子的变化。</p>
<h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>与开放地址法相比，<strong>拉链法是哈希表最常见的实现方法</strong>，大多数的编程语言都用拉链法实现哈希表，它的实现比较开放地址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间。</p>
<p>实现拉链法一般会使用数组加上链表，不过一些编程语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构，我们可以将它看成可以扩展的二维数组：</p>
<p><img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/f3dd3a752779488c9a6a74c3525407be%7Etplv-k3u1fbpfcp-watermark.image" alt="拉链法.png"></p>
<p>如上图所示，当我们需要将一个键值对 (Key6, Value6) 写入哈希表时，键值对中的键 Key6 都会先经过一个哈希函数，哈希函数返回的哈希会帮助我们选择一个桶，和开放地址法一样，选择桶的方式是直接对哈希返回的结果取模：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index := hash(<span class="string">&quot;Key6&quot;</span>) % array.<span class="built_in">len</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>选择了 2 号桶后就可以遍历当前桶中的链表了，在遍历链表的过程中会遇到以下两种情况：</p>
<ol>
<li> 找到键相同的键值对 — 更新键对应的值；</li>
<li> 没有找到键相同的键值对 — 在链表的末尾追加新的键值对；</li>
</ol>
<p>首先<strong>Go 语言采用的是哈希查找表，并且使用链表解决哈希冲突。</strong></p>
<h5 id="GO的内存模型"><a href="#GO的内存模型" class="headerlink" title="GO的内存模型"></a>GO的内存模型</h5><p>先看这一张map原理图</p>
<img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/49dfa7b81e19fbab143ddc0a7b3b7fa0.png" alt="go-map源码简单分析（map遍历为什么时随机的）" style="zoom: 80%;" />

<p>map</p>
<p>再来看看源码中map的定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/runtime/map.go  line 115</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.</span></span><br><span class="line">    <span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    count     <span class="keyword">int</span>  <span class="comment">//len(map)时，返回的值</span></span><br><span class="line">    flags     <span class="keyword">uint8</span>   <span class="comment">//表示是否有其他协程在操作map</span></span><br><span class="line">    B         <span class="keyword">uint8</span>    <span class="comment">//上图中[]bmap的&#x27;&#x27;长度&#x27;&#x27; 2^B</span></span><br><span class="line">    noverflow <span class="keyword">uint16</span>  <span class="comment">//// 溢出的bucket个数</span></span><br><span class="line">    hash0     <span class="keyword">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">    buckets    unsafe.Pointer    <span class="comment">//buckets 数组指针</span></span><br><span class="line">    oldbuckets unsafe.Pointer  <span class="comment">// 扩容的时候用于赋值的buckets数组</span></span><br><span class="line">    nevacuate  <span class="keyword">uintptr</span>       <span class="comment">// 搬迁进度</span></span><br><span class="line"></span><br><span class="line">    extra *mapextra   <span class="comment">// 用于扩容的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow    *[]*bmap</span><br><span class="line">    oldoverflow *[]*bmap</span><br><span class="line">    nextOverflow *bmap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A bucket for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [bucketCnt]<span class="keyword">uint8</span>        <span class="comment">// len为8的数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//底层定义的常量 </span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// Maximum number of key/value pairs a bucket can hold.</span></span><br><span class="line">    bucketCntBits = <span class="number">3</span></span><br><span class="line">    bucketCnt     = <span class="number">1</span> &lt;&lt; bucketCntBits</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>但这只是表面(src/runtime/hashmap.go)的结构，编译期间会给它加料，动态地创建一个新的结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">  topbits  [<span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">  keys     [<span class="number">8</span>]keytype</span><br><span class="line">  values   [<span class="number">8</span>]valuetype</span><br><span class="line">  pad      <span class="keyword">uintptr</span></span><br><span class="line">  overflow <span class="keyword">uintptr</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>bmap 就是我们常说的“桶”，**桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的(低位的B位决定bucket)**。在桶内，又会根据 <strong>key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置</strong>（一个桶内最多有8个位置）。如上图所示</p>
<p>bmap 是存放 k-v 的地方，我们把视角拉近，仔细看 bmap 的内部组成。</p>
<img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/218617d6128e5e0af684d7cbbd72c81d.png" alt="go-map源码简单分析（map遍历为什么时随机的）" style="zoom: 50%;" />

<p>上图就是 bucket 的内存模型， <strong>HOBHash 指的就是 top hash</strong>。注意到 key 和 value 是各自放在一起的，并不是 key/value/key/value/… 这样的形式。源码里说明<strong>这样的好处是在某些情况下可以省略掉 padding 字段，节省内存空间</strong>。</p>
<p>每个 bucket 设计成最多只能放 8 个 key-value 对，<strong>如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个 bucket ，通过 overflow 指针连接起来</strong>。</p>
<h3 id="创建map"><a href="#创建map" class="headerlink" title="创建map"></a>创建map</h3><p>从语法上来说，创建一个map很简单（记得<strong>key的类型必须为可比较类型</strong>）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">maps := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    maps2 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">        <span class="string">&quot;1&quot;</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;2&quot;</span>:<span class="number">2</span>,</span><br><span class="line">        <span class="string">&quot;3&quot;</span>:<span class="number">3</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> maps3 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> </span><br></pre></td></tr></table></figure>

<p>通过汇编语言可以看到，实际上底层调用的是 makemap 函数，主要做的工作就是初始化 hmap 结构体的各种字段，例如计算 B 的大小，设置哈希种子 hash0 等等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="keyword">int64</span>, h *hmap, bucket unsafe.Pointer)</span> *<span class="title">hmap</span></span> </span><br></pre></td></tr></table></figure>

<p>注意，这个函数返回的结果：*hmap，它是一个指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> </span><br></pre></td></tr></table></figure>



<h4 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h4><p>map 的一个关键点在于，哈希函数的选择。在程序启动时，会检测 cpu 是否支持 aes，如果支持，则<strong>使用 aes hash，否则使用 memhash</strong>。这是在函数 alginit() 中完成，位于路径：src/runtime/alg.go 下。</p>
<blockquote>
<p>  hash 函数，有加密型和非加密型。加密型的一般用于加密数据、数字摘要等，典型代表就是 md5、sha1、sha256、aes256 这种；非加密型的一般就是查找。在 map 的应用场景中，用的是查找。选择 hash 函数主要考察的是两点：性能、碰撞概率。</p>
</blockquote>
<h4 id="key的定位过程"><a href="#key的定位过程" class="headerlink" title="key的定位过程"></a>key的定位过程</h4><p>key 经过哈希计算后得到哈希值，共 64 个 bit 位（64位机，32位机就不讨论了，现在主流都是64位机），计算它<strong>到底要落在哪个桶时，只会用到最后 B 个 bit 位</strong>。还记得前面提到过的 B 吗？如果 B = 5，那么桶的数量，也就是 buckets 数组的长度是 2^5 = 32。<br>例如，现在有一个 key 经过哈希函数计算后，得到的哈希结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10010111 | 000011110110110010001111001010100010010110010101010 │ 01010 </span><br></pre></td></tr></table></figure>

<p><strong>用最后的 5 个 bit 位，也就是 01010，值为 10，也就是 10 号桶</strong>。这个操作实际上就是取余操作，但是取余开销太大，所以代码实现上用的位操作代替。<br><strong>再用哈希值的高 8 位，找到此 key 在 bucket 中的位置</strong>，这是在寻找已有的 key。最开始桶内还没有 key，新加入的 key 会找到第一个空位，放入。</p>
<p>buckets 编号就是桶编号，当两个不同的 key 落在同一个桶中，也就是发生了哈希冲突。<strong>冲突的解决手段是用链表法</strong>：在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。</p>
<p>这里参考一张图</p>
<img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/89f0a0cee0ed90e4b19b24f2579ab92d.png" alt="go-map源码简单分析（map遍历为什么时随机的）" style="zoom: 67%;" />

<h4 id="key定位过程"><a href="#key定位过程" class="headerlink" title="key定位过程"></a>key定位过程</h4><p>上图中，假定 B = 5，所以 bucket 总数就是 2^5 = 32。首先计算出待查找 key 的哈希，使用低 5 位 00110，找到对应的 6 号 bucket，使用高 8 位 10010111，对应十进制 151，在 6 号 bucket 中寻找 tophash 值（HOB hash）为 151 的 key，找到了 2 号槽位，这样整个查找过程就结束了。</p>
<p>如果在 bucket 中没找到，并且 overflow 不为空，还要继续去 overflow bucket 中寻找，直到找到或是所有的 key 槽位都找遍了，包括所有的 overflow bucket。</p>
<p>看看key的查找过程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 如果 h 什么都没有，返回零值</span></span><br><span class="line">  <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 写和读冲突</span></span><br><span class="line">  <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不同类型 key 使用的 hash 算法在编译期确定</span></span><br><span class="line">  alg := t.key.alg</span><br><span class="line">  <span class="comment">// 计算哈希值，并且加入 hash0 引入随机性</span></span><br><span class="line">  hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">  <span class="comment">// 比如 B=5，那 m 就是31，二进制是全 1</span></span><br><span class="line">  <span class="comment">// 求 bucket num 时，将 hash 与 m 相与，</span></span><br><span class="line">  <span class="comment">// 达到 bucket num 由 hash 的低 8 位决定的效果</span></span><br><span class="line">  m := bucketMask(h.B)</span><br><span class="line">  <span class="comment">// b 就是 bucket 的地址</span></span><br><span class="line">  b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">  <span class="comment">// oldbuckets 不为 nil，说明发生了扩容</span></span><br><span class="line">  <span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是同 size 扩容（看后面扩容的内容）</span></span><br><span class="line">    <span class="comment">// 对应条件 1 的解决方案</span></span><br><span class="line">    <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">      <span class="comment">// 新 bucket 数量是老的 2 倍</span></span><br><span class="line">      m &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求出 key 在老的 map 中的 bucket 位置</span></span><br><span class="line">    oldb := (*bmap)(add(c, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">    <span class="comment">// 如果 oldb 没有搬迁到新的 bucket</span></span><br><span class="line">    <span class="comment">// 那就在老的 bucket 中寻找</span></span><br><span class="line">    <span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">      b = oldb</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算出高 8 位的 hash</span></span><br><span class="line">  <span class="comment">// 相当于右移 56 位，只取高8位</span></span><br><span class="line">  top := tophash(hash)</span><br><span class="line">  <span class="comment">//开始寻找key</span></span><br><span class="line">  <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">    <span class="comment">// 遍历 8 个 bucket</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">      <span class="comment">// tophash 不匹配，继续</span></span><br><span class="line">      <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// tophash 匹配，定位到 key 的位置</span></span><br><span class="line">      k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">      <span class="comment">// key 是指针</span></span><br><span class="line">      <span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">        <span class="comment">// 解引用</span></span><br><span class="line">        k = *((*unsafe.Pointer)(k))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果 key 相等</span></span><br><span class="line">      <span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">        <span class="comment">// 定位到 value 的位置</span></span><br><span class="line">        v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">        <span class="comment">// value 解引用</span></span><br><span class="line">        <span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">          v = *((*unsafe.Pointer)(v))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>函数返回 h[key] 的指针，如果 h 中没有此 key，那就会返回一个 key 相应类型的零值，不会返回 nil。</p>
<p>bucket 里 key 的起始地址就是 unsafe.Pointer(b)+dataOffset。第 i 个 key 的地址就要在此基础上跨过 i 个 key 的大小；而我们又知道，value 的地址是在所有 key 之后，因此第 i 个 value 的地址还需要加上所有 key 的偏移。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key 定位公式</span></span><br><span class="line">k :=add(unsafe.Pointer(b),dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line"></span><br><span class="line"><span class="comment">// value 定位公式</span></span><br><span class="line">v:= add(unsafe.Pointer(b),dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于 bmap 起始地址的偏移：</span></span><br><span class="line">dataOffset = unsafe.Offsetof(<span class="keyword">struct</span>&#123;</span><br><span class="line">  b bmap</span><br><span class="line">  v <span class="keyword">int64</span></span><br><span class="line">&#125;&#123;&#125;.v) </span><br></pre></td></tr></table></figure>

<h4 id="map读取的两个操作"><a href="#map读取的两个操作" class="headerlink" title="map读取的两个操作"></a>map读取的两个操作</h4><p>Go 语言中读取 map 有两种语法：带 comma 和 不带 comma。当要查询的 key 不在 map 里，带 comma 的用法会返回一个 bool 型变量提示 key 是否在 map 中；而不带 comma 的语句则会返回一个 value 类型的零值。如果 value 是 int 型就会返回 0，如果 value 是 string 类型，就会返回空字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value := maps[<span class="string">&quot;1&quot;</span>]</span><br><span class="line">value2,ok := maps[<span class="string">&quot;1&quot;</span>] </span><br></pre></td></tr></table></figure>

<p>以前一直觉得好神奇，怎么实现的？这其实是编译器在背后做的工作：分析代码后，将两种语法对应到底层两个不同的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/runtime/map.go line 394</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess2</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="params">(unsafe.Pointer, <span class="keyword">bool</span>)</span></span> </span><br></pre></td></tr></table></figure>

<h4 id="map如何扩容"><a href="#map如何扩容" class="headerlink" title="map如何扩容"></a>map如何扩容</h4><p>使用哈希表的目的就是要快速查找到目标 key，然而，随着向 map 中添加的 key 越来越多，key 发生碰撞的概率也越来越大。bucket 中的 8 个 cell 会被逐渐塞满，查找、插入、删除 key 的效率也会越来越低。<br>Go 语言采用一个 bucket 里装载 8 个 key，定位到某个 bucket 后，还需要再定位到具体的 key，这实际上又用了时间换空间。<br>所有的 key 都落在了同一个 bucket 里，a直接退化成了链表，各种操作的效率直接降为 O(n)。</p>
<p>因此，需要有一个指标来衡量前面描述的情况，这就是 装载因子。Go 源码里这样定义 装载因子：loadFactor := count /(2^B)</p>
<p>count 就是 map 的元素个数，2^B 表示 bucket 数量。</p>
<p><strong>再来说触发 map 扩容的时机：在向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容：</strong></p>
<ol>
<li> <strong>装载因子超过阈值，源码里定义的阈值是 6.5。</strong></li>
<li><strong>overflow 的 bucket 数量过多：当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，overflow 的 bucket 数量超过 2^B；扩容</strong><br> <strong>当 B &gt;= 15，也就是 bucket 总数 2^B 大于等于 2^15， overflow 的 bucket 数量超过 2^15。扩容。</strong></li>
</ol>
<p>触发扩容的代码如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we hit the max load factor or we have too many overflow buckets,</span></span><br><span class="line">    <span class="comment">// and we&#x27;re not already in the middle of growing, start growing.</span></span><br><span class="line">    <span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">        hashGrow(t, h)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="keyword">int</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="keyword">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="keyword">uint16</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// If the threshold is too low, we do extraneous work.</span></span><br><span class="line">    <span class="comment">// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.</span></span><br><span class="line">    <span class="comment">// &quot;too many&quot; means (approximately) as many overflow buckets as regular buckets.</span></span><br><span class="line">    <span class="comment">// See incrnoverflow for more details.</span></span><br><span class="line">    <span class="keyword">if</span> B &gt; <span class="number">15</span> &#123;</span><br><span class="line">        B = <span class="number">15</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The compiler doesn&#x27;t see here that B &lt; 16; mask B to generate shorter shift code.</span></span><br><span class="line">    <span class="keyword">return</span> noverflow &gt;= <span class="keyword">uint16</span>(<span class="number">1</span>)&lt;&lt;(B&amp;<span class="number">15</span>)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>第 1 点：我们知道，每个 bucket 有 8 个空位，在没有溢出，且所有的桶都装满了的情况下，装载因子算出来的结果是 8。因此当装载因子超过 6.5 时，表明很多 bucket 都快要装满了，查找效率和插入效率都变低了。在这个时候进行扩容是有必要的。</p>
<p>第 2 点：是对第 1 点的补充。就是说在装载因子比较小的情况下，这时候 map 的查找和插入效率也很低，而第 1 点识别不出来这种情况。表面现象就是计算装载因子的分子比较小，即 map 里元素总数少，但是 bucket 数量多（真实分配的 bucket 数量多，包括大量的 overflow bucket）。</p>
<p>不难想像造成这种情况的原因：不停地插入、删除元素。先插入很多元素，导致创建了很多 bucket，但是装载因子达不到第 1 点的临界值，未触发扩容来缓解这种情况。之后，删除元素降低元素总数量，再插入很多元素，导致创建很多的 overflow bucket，但就是不会触犯第 1 点的规定，你能拿我怎么办？overflow bucket 数量太多，导致 key 会很分散，查找插入效率低得吓人，因此出台第 2 点规定。这就像是一座空城，房子很多，但是住户很少，都分散了，找起人来很困难。</p>
<p>对于条件 1，元素太多，而 bucket 数量太少，很简单：将 B 加 1，bucket 最大数量（2^B）直接变成原来 bucket 数量的 2 倍。于是，就有新老 bucket 了。注意，这时候元素都在老 bucket 里，还没迁移到新的 bucket 来。而且，新 bucket 只是最大数量变为原来最大数量（2^B）的 2 倍（2^B * 2）。</p>
<p>如果插入 map 的 key 哈希都一样，就会落到同一个 bucket 里，超过 8 个就会产生 overflow bucket，结果也会造成 overflow bucket 数过多。移动元素其实解决不了问题，因为这时整个哈希表已经退化成了一个链表，操作效率变成了 O(n)。</p>
<p>再来看一下扩容具体是怎么做的。由于 map 扩容需要将原有的 key/value 重新搬迁到新的内存地址，如果有大量的 key/value 需要搬迁，会非常影响性能。因此 <strong>Go map 的扩容采取了一种称为“渐进式”地方式</strong>，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。</p>
<p>hashGrow() 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。真正搬迁 buckets 的动作在 growWork() 函数中，而调用 growWork() 函数的动作是在 mapassign 和 mapdelete 函数中。也就是插入或修改、删除 key 的时候，都会尝试进行搬迁 buckets 的工作。先检查 oldbuckets 是否搬迁完毕，具体来说就是检查 oldbuckets 是否为 nil。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">  <span class="comment">// B+1 相当于是原来 2 倍的空间</span></span><br><span class="line">  bigger := <span class="keyword">uint8</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 对应条件 2</span></span><br><span class="line">  <span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line">    <span class="comment">// 进行等量的内存扩容，所以 B 不变</span></span><br><span class="line">    bigger = <span class="number">0</span></span><br><span class="line">    h.flags |= sameSizeGrow</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将老 buckets 挂到 buckets 上</span></span><br><span class="line">  oldbuckets := h.buckets</span><br><span class="line">  <span class="comment">// 申请新的 buckets 空间</span></span><br><span class="line">  newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">//先把 h.flags 中 iterator 和 oldIterator 对应位清 0</span></span><br><span class="line">    <span class="comment">//如果 iterator 位为 1，把它转接到 oldIterator 位，使得 oldIterator 标志位变成1</span></span><br><span class="line">    <span class="comment">//可以理解为buckets 现在挂到了 oldBuckets 名下了，将对应的标志位也转接过去</span></span><br><span class="line">  flags := h.flags &amp;^ (iterator | oldIterator)</span><br><span class="line">  <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line">    flags |= oldIterator</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// commit the grow (atomic wrt gc)</span></span><br><span class="line">  h.B += bigger</span><br><span class="line">  h.flags = flags</span><br><span class="line">  h.oldbuckets = oldbuckets</span><br><span class="line">  h.buckets = newbuckets</span><br><span class="line">  <span class="comment">// 搬迁进度为 0</span></span><br><span class="line">  h.nevacuate = <span class="number">0</span></span><br><span class="line">  <span class="comment">// overflow buckets 数为 0</span></span><br><span class="line">  h.noverflow = <span class="number">0</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>主要是申请到了新的 buckets 空间，把相关的标志位都进行了处理：例如标志 nevacuate 被置为 0， 表示当前搬迁进度为 0。<br>转移的几个标志位如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能有迭代器使用 buckets</span></span><br><span class="line">iterator = <span class="number">1</span></span><br><span class="line"><span class="comment">// 可能有迭代器使用 oldbuckets</span></span><br><span class="line">oldIterator = <span class="number">2</span></span><br><span class="line"><span class="comment">// 有协程正在向 map 中写入 key</span></span><br><span class="line">hashWriting  =  <span class="number">4</span></span><br><span class="line"><span class="comment">// 等量扩容（对应条件 2）</span></span><br><span class="line">sameSizeGrow  = <span class="number">8</span></span><br><span class="line"><span class="comment">// 可能有迭代器使用 buckets</span></span><br><span class="line">iterator = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能有迭代器使用 oldbuckets</span></span><br><span class="line">oldIterator = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有协程正在向 map 中写入 key</span></span><br><span class="line">hashWriting = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等量扩容（对应条件 2）</span></span><br><span class="line">sameSizeGrow = <span class="number">8</span> </span><br></pre></td></tr></table></figure>



<p>再来看看真正执行搬迁工作的 growWork() 函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 搬迁正在使用的旧 bucket</span></span><br><span class="line">  evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line">  <span class="comment">// 再搬迁一个 bucket，以加快搬迁进程</span></span><br><span class="line">  <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">    evacuate(t, h, h.nevacuate)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span> <span class="title">growing</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> h.oldbuckets != <span class="literal">nil</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>bucket&amp;h.oldbucketmask() 这行代码，如源码注释里说的，是为了确认搬迁的 bucket 是我们正在使用的 bucket。oldbucketmask() 函数返回扩容前的 map 的 bucketmask。</p>
<p>搬迁过程evacuate源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> evacDst <span class="keyword">struct</span> &#123;</span><br><span class="line">  b *bmap          <span class="comment">// 表示bucket 移动的目标地址</span></span><br><span class="line">  i <span class="keyword">int</span>            <span class="comment">// 指向 x,y 中 key/val 的 index</span></span><br><span class="line">  k unsafe.Pointer <span class="comment">// 指向 x，y 中的 key</span></span><br><span class="line">  v unsafe.Pointer <span class="comment">// 指向 x，y 中的 value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuate</span><span class="params">(t *maptype, h *hmap, oldbucket <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 定位老的 bucket 地址</span></span><br><span class="line">  b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">  <span class="comment">// 计算容量 结果是 2^B，如 B = 5，结果为32</span></span><br><span class="line">  newbit := h.noldbuckets()</span><br><span class="line">  <span class="comment">// 如果 b 没有被搬迁过</span></span><br><span class="line">  <span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">    <span class="comment">// 默认是等 size 扩容，前后 bucket 序号不变</span></span><br><span class="line">    <span class="keyword">var</span> xy [<span class="number">2</span>]evacDst</span><br><span class="line">    <span class="comment">// 使用 x 来进行搬迁</span></span><br><span class="line">    x := &amp;xy[<span class="number">0</span>]</span><br><span class="line">    x.b = (*bmap)(add(h.buckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">    x.k = add(unsafe.Pointer(x.b), dataOffset)</span><br><span class="line">    x.v = add(x.k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是等 size 扩容，前后 bucket 序号有变</span></span><br><span class="line">    <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">      <span class="comment">// 使用 y 来进行搬迁</span></span><br><span class="line">      y := &amp;xy[<span class="number">1</span>]</span><br><span class="line">      <span class="comment">// y 代表的 bucket 序号增加了 2^B</span></span><br><span class="line">      y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">      y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">      y.v = add(y.k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有的 bucket，包括 overflow buckets b 是老的 bucket 地址</span></span><br><span class="line">    <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">      k := add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">      v := add(k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">      <span class="comment">// 遍历 bucket 中的所有 cell</span></span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bucketCnt; i, k, v = i+<span class="number">1</span>, add(k, <span class="keyword">uintptr</span>(t.keysize)), add(v, <span class="keyword">uintptr</span>(t.valuesize)) &#123;</span><br><span class="line">        <span class="comment">// 当前 cell 的 top hash 值</span></span><br><span class="line">        top := b.tophash[i]</span><br><span class="line">        <span class="comment">// 如果 cell 为空，即没有 key</span></span><br><span class="line">        <span class="keyword">if</span> top == empty &#123;</span><br><span class="line">          <span class="comment">// 那就标志它被&quot;搬迁&quot;过</span></span><br><span class="line">          b.tophash[i] = evacuatedEmpty</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正常不会出现这种情况</span></span><br><span class="line">        <span class="comment">// 未被搬迁的 cell 只可能是 empty 或是</span></span><br><span class="line">        <span class="comment">// 正常的 top hash（大于 minTopHash）</span></span><br><span class="line">        <span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">          throw(<span class="string">&quot;bad map state&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 是指针，则解引用</span></span><br><span class="line">        k2 := k</span><br><span class="line">        <span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">          k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> useY <span class="keyword">uint8</span></span><br><span class="line">        <span class="comment">// 如果不是等量扩容</span></span><br><span class="line">        <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">          <span class="comment">// 计算 hash 值，和 key 第一次写入时一样</span></span><br><span class="line">          hash := t.key.alg.hash(k2, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">          <span class="comment">// 如果有协程正在遍历 map 如果出现 相同的 key 值，算出来的 hash 值不同</span></span><br><span class="line">          <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &amp;&amp; !t.reflexivekey &amp;&amp; !t.key.alg.equal(k2, k2) &#123;</span><br><span class="line">            <span class="comment">// useY =1 使用位置Y</span></span><br><span class="line">            useY = top &amp; <span class="number">1</span></span><br><span class="line">            top = tophash(hash)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第 B 位置 不是 0</span></span><br><span class="line">            <span class="keyword">if</span> hash&amp;newbit != <span class="number">0</span> &#123;</span><br><span class="line">              <span class="comment">//使用位置Y</span></span><br><span class="line">              useY = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> evacuatedX+<span class="number">1</span> != evacuatedY &#123;</span><br><span class="line">          throw(<span class="string">&quot;bad evacuatedN&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//决定key是裂变到 X 还是 Y</span></span><br><span class="line">        b.tophash[i] = evacuatedX + useY <span class="comment">// evacuatedX + 1 == evacuatedY</span></span><br><span class="line">        dst := &amp;xy[useY]                 <span class="comment">// evacuation destination</span></span><br><span class="line">        <span class="comment">// 如果 xi 等于 8，说明要溢出了</span></span><br><span class="line">        <span class="keyword">if</span> dst.i == bucketCnt &#123;</span><br><span class="line">          <span class="comment">// 新建一个 bucket</span></span><br><span class="line">          dst.b = h.newoverflow(t, dst.b)</span><br><span class="line">          <span class="comment">// xi 从 0 开始计数</span></span><br><span class="line">          dst.i = <span class="number">0</span></span><br><span class="line">          <span class="comment">//key移动的位置</span></span><br><span class="line">          dst.k = add(unsafe.Pointer(dst.b), dataOffset)</span><br><span class="line">          <span class="comment">//value 移动的位置</span></span><br><span class="line">          dst.v = add(dst.k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 top hash 值</span></span><br><span class="line">        dst.b.tophash[dst.i&amp;(bucketCnt<span class="number">-1</span>)] = top <span class="comment">// mask dst.i as an optimization, to avoid a bounds check</span></span><br><span class="line">        <span class="comment">// key 是指针</span></span><br><span class="line">        <span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">          <span class="comment">// 将原 key（是指针）复制到新位置</span></span><br><span class="line">          *(*unsafe.Pointer)(dst.k) = k2 <span class="comment">// copy pointer</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 将原 key（是值）复制到新位置</span></span><br><span class="line">          typedmemmove(t.key, dst.k, k) <span class="comment">// copy value</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//value同上</span></span><br><span class="line">        <span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">          *(*unsafe.Pointer)(dst.v) = *(*unsafe.Pointer)(v)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          typedmemmove(t.elem, dst.v, v)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定位到下一个 cell</span></span><br><span class="line">        dst.i++</span><br><span class="line">        dst.k = add(dst.k, <span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">        dst.v = add(dst.v, <span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Unlink the overflow buckets &amp; clear key/value to help GC.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// bucket搬迁完毕 如果没有协程在使用老的 buckets，就把老 buckets 清除掉，帮助gc</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;oldIterator == <span class="number">0</span> &amp;&amp; t.bucket.kind&amp;kindNoPointers == <span class="number">0</span> &#123;</span><br><span class="line">      b := add(h.oldbuckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize))</span><br><span class="line">      ptr := add(b, dataOffset)</span><br><span class="line">      n := <span class="keyword">uintptr</span>(t.bucketsize) - dataOffset</span><br><span class="line">      memclrHasPointers(ptr, n)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新搬迁进度</span></span><br><span class="line">  <span class="keyword">if</span> oldbucket == h.nevacuate &#123;</span><br><span class="line">    advanceEvacuationMark(h, t, newbit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>通过前面的说明我们知道，应对条件 1，新的 buckets 数量是之前的一倍，应对条件 2，新的 buckets 数量和之前相等。<br>对于条件 1，从老的 buckets 搬迁到新的 buckets，由于 bucktes 数量不变，因此可以按序号来搬，比如原来在 0 号 bucktes，到新的地方后，仍然放在 0 号 buckets。</p>
<p>对于条件 2，就没这么简单了。要重新计算 key 的哈希，才能决定它到底落在哪个 bucket。例如，原来 B = 5，计算出 key 的哈希后，只用看它的低 5 位，就能决定它落在哪个 bucket。扩容后，B 变成了 6，因此需要多看一位，它的低 6 位决定 key 落在哪个 bucket。这称为 rehash。</p>
<p><img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/548d2e743708ee02f875a57decddc18e.png" alt="go-map源码简单分析（map遍历为什么时随机的）"></p>
<p>rehash</p>
<p>因此，某个 key 在搬迁前后 bucket 序号可能和原来相等，也可能是相比原来加上 2^B（原来的 B 值），取决于 hash 值 第 6 bit 位是 0 还是 1。</p>
<p><strong>理解了上面 bucket 序号的变化，我们就可以回答另一个问题了：为什么遍历 map 是无序的？</strong></p>
<p><strong>map 在扩容后，会发生 key 的搬迁，</strong>原来落在同一个 bucket 中的 key，搬迁后，有些 key 就要远走高飞了（bucket 序号加上了 2^B）。而遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大的变化，有些 key 飞上高枝，有些 key 则原地不动。这样，遍历 map 的结果就不可能按原来的顺序了。</p>
<p><strong>按理说每次遍历这样的 map 都会返回一个固定顺序的 key/value 序列吧。的确是这样，但是 Go 杜绝了这种做法，</strong>因为这样会给新手程序员带来误解，以为这是一定会发生的事情，在某些情况下，可能会酿成大错。</p>
<p>Go 做得更绝，当我们在遍历 map 时，并不是固定地从 0 号 bucket 开始遍历，每次都是从一个随机值序号的 bucket 开始遍历，并且是从这个 bucket 的一个随机序号的 cell 开始遍历。这样，即使你是一个写死的 map，仅仅只是遍历它，也不太可能会返回一个固定序列的 key/value 对了</p>
<p>再明确一个问题：如果扩容后，B 增加了 1，意味着 buckets 总数是原来的 2 倍，原来 1 号的桶“裂变”到两个桶。</p>
<p>例如，原始 B = 2，1号 bucket 中有 2 个 key 的哈希值低 3 位分别为：010，110。由于原来 B = 2，所以低 2 位 10 决定它们落在 2 号桶，现在 B 变成 3，所以 010、 110 分别落入 2、6 号桶。(这与数据库的动态hash索引类似)</p>
<img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/d57b1782ea46c771a236797bce78f9b1.png" alt="go-map源码简单分析（map遍历为什么时随机的）" style="zoom:50%;" />

<p>有一个特殊情况是：有一种 key，每次对它计算 hash，得到的结果都不一样。这个 key 就是 math.NaN() 的结果，它的含义是 nota number，类型是 float64。当它作为 map 的 key，在搬迁的时候，会遇到一个问题：再次计算它的哈希值和它当初插入 map 时的计算出来的哈希值不一样！</p>
<p>你可能想到了，这样带来的一个后果是，这个 key 是永远不会被 Get 操作获取的！当我使用 m[math.NaN()] 语句的时候，是查不出来结果的。这个 key 只有在遍历整个 map 的时候，才有机会现身。所以，可以向一个 map 插入任意数量的 math.NaN() 作为 key。</p>
<p>下面通过图来宏观地看一下扩容前后的变化。</p>
<p>扩容前，B = 2，共有 4 个 buckets，lowbits 表示 hash 值的低位。假设我们不关注其他 buckets 情况，专注在 2 号 bucket。并且假设 overflow 太多，触发了等量扩容（对应于前面的条件 2）。</p>
<p><img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/c874b78e4e848c734c140bec8c3cfaa2.png" alt="go-map源码简单分析（map遍历为什么时随机的）"></p>
<p>扩容完成后，overflow bucket 消失了，key 都集中到了一个 bucket，更为紧凑了，提高了查找的效率。</p>
<img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/be34bd4ef615d97b0591b13f4defdfc2.png" alt="go-map源码简单分析（map遍历为什么时随机的）" style="zoom:80%;" />

<p>假设触发了 2 倍的扩容，那么扩容完成后，老 buckets 中的 key 分裂到了 2 个 新的 bucket。一个在 x part，一个在 y 的 part。依据是 hash 的 lowbits。新 map 中 0-3称为 x part， 4-7 称为 y part。</p>
<p><img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/f465b1492d831e61559c2bf9a2f47462.png" alt="go-map源码简单分析（map遍历为什么时随机的）"></p>
<h3 id="map遍历"><a href="#map遍历" class="headerlink" title="map遍历"></a>map遍历</h3><p>本来 map 的遍历过程比较简单：遍历所有的 bucket 以及它后面挂的 overflow bucket，然后挨个遍历 bucket 中的所有 cell。每个 bucket 中包含 8 个 cell，从有 key 的 cell 中取出 key 和 value，这个过程就完成了。</p>
<p>但是，现实并没有这么简单。还记得前面讲过的扩容过程吗？扩容过程不是一个原子的操作，它每次最多只搬运 2 个 bucket，所以如果触发了扩容操作，那么在很长时间里，map 的状态都是处于一个中间态：有些 bucket 已经搬迁到新家，而有些 bucket 还待在老地方。</p>
<p>因此，遍历如果发生在扩容的过程中，就会涉及到遍历新老 bucket 的过程，这是难点所在。</p>
<p>关于 map 迭代，先是调用 mapiterinit 函数初始化迭代器，然后循环调用 mapiternext 函数进行 map 迭代。</p>
<p><img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/7d6850297eb459093f60af43d8336a08.png" alt="go-map源码简单分析（map遍历为什么时随机的）"></p>
<p>前面已经提到过，即使是对一个写死的 map 进行遍历，每次出来的结果也是无序的。下面我们就可以近距离地观察他们的实现了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiterinit</span><span class="params">(t *maptype, h *hmap, it *hiter)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  it.t = t</span><br><span class="line">  it.h = h</span><br><span class="line">  it.B = h.B</span><br><span class="line">  it.buckets = h.buckets</span><br><span class="line">  <span class="keyword">if</span> t.bucket.kind&amp;kindNoPointers != <span class="number">0</span> &#123;</span><br><span class="line">    h.createOverflow()</span><br><span class="line">    it.overflow = h.extra.overflow</span><br><span class="line">    it.oldoverflow = h.extra.oldoverflow</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  r := <span class="keyword">uintptr</span>(fastrand())</span><br><span class="line">  <span class="keyword">if</span> h.B &gt; <span class="number">31</span>-bucketCntBits &#123;</span><br><span class="line">    r += <span class="keyword">uintptr</span>(fastrand()) &lt;&lt; <span class="number">31</span></span><br><span class="line">  &#125;</span><br><span class="line">  it.startBucket = r &amp; bucketMask(h.B)</span><br><span class="line">  it.offset = <span class="keyword">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))</span><br><span class="line">  it.bucket = it.startBucket</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  mapiternext(it)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>重点是fastrand 的部分，是一个生成随机数的方法：它生成了随机数。用于决定从哪里开始循环迭代。更具体的话就是根据随机数，选择一个桶位置作为起始点进行遍历迭代因此每次重新 for range map，你见到的结果都是不一样的。那是因为它的起始位置根本就不固定！</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ...</span><br><span class="line"><span class="comment">// decide where to start</span></span><br><span class="line">r := <span class="keyword">uintptr</span>(fastrand())</span><br><span class="line"><span class="keyword">if</span> h.B &gt; <span class="number">31</span>-bucketCntBits &#123;</span><br><span class="line">  r += <span class="keyword">uintptr</span>(fastrand()) &lt;&lt; <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line">it.startBucket = r &amp; bucketMask(h.B)</span><br><span class="line">it.offset = <span class="keyword">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator state</span></span><br><span class="line">it.bucket = it.startBucket </span><br></pre></td></tr></table></figure>



<h3 id="map的赋值和更新"><a href="#map的赋值和更新" class="headerlink" title="map的赋值和更新"></a>map的赋值和更新</h3><p>向 map 中插入或者修改 key，最终调用的是 mapassign 函数。</p>
<p><strong>实际上插入或修改 key 的语法是一样的，只不过前者操作的 key 在 map 中不存在，而后者操作的 key 存在 map 中。</strong></p>
<p>mapassign 有一个系列的函数，根据 key 类型的不同，编译器会将其优化为相应的“快速函数”。</p>
<p>整体来看，流程非常得简单：对 key 计算 hash 值，根据 hash 值按照之前的流程，找到要赋值的位置（可能是插入新 key，也可能是更新老 key），对相应位置进行赋值。</p>
<p>源码大体和之前讲的类似，核心还是一个双层循环，外层遍历 bucket 和它的 overflow bucket，内层遍历整个 bucket 的各个 cell</p>
<p>函数首先会检查 map 的标志位 flags。如果 flags 的写标志位此时被置 1 了，说明有其他协程在执行“写”操作，进而导致程序 panic。这也说明了 map 对协程是不安全的。</p>
<p>通过前文我们知道扩容是渐进式的，如果 map 处在扩容的过程中，那么当 key 定位到了某个 bucket 后，需要确保这个 bucket 对应的老 bucket 完成了迁移过程。即老 bucket 里的 key 都要迁移到新的 bucket 中来（分裂到 2 个新 bucket），才能在新的 bucket 中进行插入或者更新的操作。</p>
<p>上面说的操作是在函数靠前的位置进行的，只有进行完了这个搬迁操作后，我们才能放心地在新 bucket 里定位 key 要安置的地址，再进行之后的操作。</p>
<p>现在到了定位 key 应该放置的位置了，所谓找准自己的位置很重要。准备两个指针，一个（ inserti）指向 key 的 hash 值在 tophash 数组所处的位置，另一个( insertk)指向 cell 的位置（也就是 key 最终放置的地址），当然，对应 value 的位置就很容易定位出来了。这三者实际上都是关联的，在 tophash 数组中的索引位置决定了 key 在整个 bucket 中的位置（共 8 个 key），而 value 的位置需要“跨过” 8 个 key 的长度。</p>
<p>在循环的过程中，inserti 和 insertk 分别指向第一个找到的空闲的 cell。如果之后在 map 没有找到 key 的存在，也就是说原来 map 中没有此 key，这意味着插入新 key。那最终 key 的安置地址就是第一次发现的“空位”（tophash 是 empty）。</p>
<p>如果这个 bucket 的 8 个 key 都已经放置满了，那在跳出循环后，发现 inserti 和 insertk 都是空，这时候需要在 bucket 后面挂上 overflow bucket。当然，也有可能是在 overflow bucket 后面再挂上一个 overflow bucket。这就说明，太多 key hash 到了此 bucket。</p>
<p>在正式安置 key 之前，还要检查 map 的状态，看它是否需要进行扩容。如果满足扩容的条件，就主动触发一次扩容操作。</p>
<p>这之后，整个之前的查找定位 key 的过程，还得再重新走一次。因为扩容之后，key 的分布都发生了变化。</p>
<p>最后，会更新 map 相关的值，如果是插入新 key，map 的元素数量字段 count 值会加 1；在函数之初设置的 hashWriting 写标志出会清零。</p>
<h3 id="map的删除"><a href="#map的删除" class="headerlink" title="map的删除"></a>map的删除</h3><p>写操作底层的执行函数是 mapdelete</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> </span><br></pre></td></tr></table></figure>



<p>它首先会检查 h.flags 标志，如果发现写标位是 1，直接 panic，因为这表明有其他协程同时在进行写操作。</p>
<p>计算 key 的哈希，找到落入的 bucket。检查此 map 如果正在扩容的过程中，直接触发一次搬迁操作。</p>
<p>删除操作同样是两层循环，核心还是找到 key 的具体位置。寻找过程都是类似的，在 bucket 中挨个 cell 寻找。</p>
<p>找到对应位置后，对 key 或者 value 进行“清零”操作：<br>最后，将 count 值减 1，将对应位置的 tophash 值置成 Empty。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> raceenabled &amp;&amp; h != <span class="literal">nil</span> &#123;</span><br><span class="line">    callerpc := getcallerpc()</span><br><span class="line">    pc := funcPC(mapdelete)</span><br><span class="line">    racewritepc(unsafe.Pointer(h), callerpc, pc)</span><br><span class="line">    raceReadObjectPC(t.key, key, callerpc, pc)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> msanenabled &amp;&amp; h != <span class="literal">nil</span> &#123;</span><br><span class="line">    msanread(key, t.key.size)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  alg := t.key.alg</span><br><span class="line">  hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set hashWriting after calling alg.hash, since alg.hash may panic,</span></span><br><span class="line">  <span class="comment">// in which case we have not actually done a write (delete).</span></span><br><span class="line">  h.flags |= hashWriting</span><br><span class="line"></span><br><span class="line">  bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">  <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">    growWork(t, h, bucket)</span><br><span class="line">  &#125;</span><br><span class="line">  b := (*bmap)(add(h.buckets, bucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">  top := tophash(hash)</span><br><span class="line">search:</span><br><span class="line">  <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">      k2 := k</span><br><span class="line">      <span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">        k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> !alg.equal(key, k2) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Only clear key if there are pointers in it.</span></span><br><span class="line">            <span class="comment">// 对key清零</span></span><br><span class="line">      <span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">        *(*unsafe.Pointer)(k) = <span class="literal">nil</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.key.kind&amp;kindNoPointers == <span class="number">0</span> &#123;</span><br><span class="line">        memclrHasPointers(k, t.key.size)</span><br><span class="line">      &#125;</span><br><span class="line">      v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">            <span class="comment">// 对value清零</span></span><br><span class="line">      <span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">        *(*unsafe.Pointer)(v) = <span class="literal">nil</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.elem.kind&amp;kindNoPointers == <span class="number">0</span> &#123;</span><br><span class="line">        memclrHasPointers(v, t.elem.size)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        memclrNoHeapPointers(v, t.elem.size)</span><br><span class="line">      &#125;</span><br><span class="line">            <span class="comment">// 高位hash清零</span></span><br><span class="line">      b.tophash[i] = empty</span><br><span class="line">            <span class="comment">// 个数减一</span></span><br><span class="line">      h.count--</span><br><span class="line">      <span class="keyword">break</span> search</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  h.flags &amp;^= hashWriting</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>Go 语言中只要是可比较的类型都可以作为 key。除开 slice，map，functions 这几种类型，其他类型都是 OK 的。具体包括：布尔值、数字、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组。这些类型的共同特征是支持 == 和 != 操作符， k1==k2 时，可认为 k1 和 k2 是同一个 key。如果是结构体，则需要它们的字段值都相等，才被认为是相同的 key。<br>当用 float64 作为 key 的时候，先要将其转成 unit64 类型，再插入 key 中。<br>顺便说一句，任何类型都可以作为 value，包括 map 类型。</p>
<h4 id="map的并发访问"><a href="#map的并发访问" class="headerlink" title="map的并发访问"></a>map的并发访问</h4><p><strong>map 并不是一个线程安全的数据结构。同时读写一个 map 是不安全的，如果被检测到，会直接 panic。</strong></p>
<p>解决方法1：读写锁 sync.RWMutex。将map与读写锁定义在一个结构体，访问时加锁解锁</p>
<p>解决方法2：使用golang提供的 sync.Map</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  m := sync.Map&#123;&#125;</span><br><span class="line">  m.Store(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">  i := <span class="number">0</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="number">1000</span> &#123;</span><br><span class="line">      m.Store(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="number">1000</span> &#123;</span><br><span class="line">      m.Store(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="number">1000</span> &#123;</span><br><span class="line">      fmt.Println(m.Load(<span class="number">1</span>))</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    runtime.GC()</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>最后看一看下列代码如果觉得和想的不一样，可以试试并想想为什么。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">//m == nil</span></span><br><span class="line">  <span class="built_in">delete</span>(m,<span class="string">&quot;name&quot;</span>) <span class="comment">//不会panic</span></span><br><span class="line">  fmt.Println(m[<span class="string">&quot;name&quot;</span>]) <span class="comment">//返回类型默认值</span></span><br><span class="line">  m[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Li&quot;</span> <span class="comment">//panic </span></span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，<strong>Go 语言中，通过哈希查找表实现 map，用链表法解决哈希冲突</strong>。</p>
<p>通过 key 的哈希值将 key 散落到不同的桶中，每个桶中有 8 个 cell。哈希值的低位决定桶序号，高位标识同一个桶中的不同 key。</p>
<p>当向桶中添加了很多 key，造成元素过多，或者溢出桶太多，就会触发扩容。扩容分为等量扩容和 2 倍容量扩容。扩容后，原来一个 bucket 中的 key 一分为二，会被重新分配到两个桶中。</p>
<p>扩容过程是渐进的，主要是防止一次扩容需要搬迁的 key 数量过多，引发性能问题。触发扩容的时机是增加了新元素，bucket 搬迁的时机则发生在赋值、删除期间，每次最多搬迁两个 bucket。</p>
<p>查找、赋值、删除的一个很核心的内容是如何定位到 key 所在的位置.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/24/blog/go-slice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/blog/go-slice/" class="post-title-link" itemprop="url">go 数组和切片</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-24 15:50:31 / Modified: 16:29:14" itemprop="dateCreated datePublished" datetime="2022-01-24T15:50:31+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Go语言的<code>array</code>和<code>slice</code>不同点，今天我们就从底层触发。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>几乎所有计算机语言，数组的实现都是相似的：一段连续的内存，Go语言也一样，Go语言的数组底层实现就是一段连续的内存空间。每个元素有唯一一个索引(或者叫<code>下标</code>)来访问。</p>
<p>数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。</p>
<p>如下图所示，数组的内部实现逻辑图:</p>
<p><img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/goarray.png" alt="img"></p>
<p>由于内存连续，CPU很容易计算索引(即数组的<code>下标</code>)，可以快速迭代数组里的所有元素。<br>Go语言的数组不同于C语言或者其他语言的数组，<strong>C语言的数组变量是指向数组第一个元素的指针；而Go语言的数组是一个值，Go语言中的数组是值类型，一个数组变量就表示着整个数组，意味着Go语言的数组在传递的时候，传递的是原数组的拷贝</strong>。你可以理解为Go语言的数组是一种有序的<code>struct</code></p>
<h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><p>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p>
<p>切片是一个很小的对象，是对数组进行了抽象，并提供相关的操作方法。<strong>切片有三个属性字段：长度、容量和指向数组的指针</strong>。</p>
<p><img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/slice_1011.png" alt="image"></p>
<p>上图中，<code>ptr</code>指的是指向array的pointer，<code>len</code>是指切片的长度, <code>cap</code>指的是切片的容量。现在，我想你对数组和切片有了一个本质的认识。</p>
<h2 id="切片有多种声明方式，每种初始化方式对应的逻辑图是怎样的呢？"><a href="#切片有多种声明方式，每种初始化方式对应的逻辑图是怎样的呢？" class="headerlink" title="切片有多种声明方式，每种初始化方式对应的逻辑图是怎样的呢？"></a>切片有多种声明方式，每种初始化方式对应的逻辑图是怎样的呢？</h2><h3 id="对于s-make-byte-5-和s-byte-的方式"><a href="#对于s-make-byte-5-和s-byte-的方式" class="headerlink" title="对于s := make([]byte, 5)和s := []byte{...}的方式"></a>对于<code>s := make([]byte, 5)</code>和<code>s := []byte&#123;...&#125;</code>的方式</h3><p><img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/slice200.png" alt="image"></p>
<h3 id="对于s-s-2-4-的方式"><a href="#对于s-s-2-4-的方式" class="headerlink" title="对于s = s[2:4]的方式"></a>对于<code>s = s[2:4]</code>的方式</h3><p><img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/slice300.png" alt="image"></p>
<p>len=2， cap=3。 共用之前的切片，内存没有重新分配。</p>
<h3 id="对于nil的切片即var-s-byte对应的逻辑图是"><a href="#对于nil的切片即var-s-byte对应的逻辑图是" class="headerlink" title="对于nil的切片即var s []byte对应的逻辑图是"></a>对于<code>nil</code>的切片即<code>var s []byte</code>对应的逻辑图是</h3><img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/slice400.png" alt="image" style="zoom: 50%;" />

<p>在此有一个说明：<code>nil</code>切片和<code>空</code>切片是不太一样的，空切片即<code>s := make([]byte, 0)</code>或者<code>s := []byte&#123;&#125;</code>出来的切片<br>空切片的逻辑图为：</p>
<img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/slice500.png" alt="image" style="zoom:50%;" />

<p><strong>空切片指针不为nil，而nil切片指针为nil。但是，不管是空切片还是nil切片，对其调用内置函数<code>append()</code>、<code>len</code>和<code>cap</code>的效果都是一样的，感受不到任何区别。</strong></p>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>slice这种数据结构便于使用和管理数据集合，可以理解为是一种“动态数组”，<code>slice</code>也是围绕动态数组的概念来构建的。既然是动态数组，那么slice是如何扩容的呢？</p>
<p>请记住以下两条规则：</p>
<ul>
<li>  <strong>如果切片的容量小于1024个元素，那么扩容的时候slice的cap就翻番，乘以2</strong>；</li>
<li>  <strong>一旦元素个数超过1024个元素，增长因子就变成1.25</strong>，即每次增加原来容量的四分之一。</li>
<li>  <strong>如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组</strong>，如果扩容之后，<strong>超过了原数组的容量</strong>，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组。</li>
</ul>
<p>知道了一下规则，请看下面程序,试问输出结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">	slice := arr[<span class="number">0</span>:<span class="number">2</span>] <span class="comment">// 左闭右开  10,20</span></span><br><span class="line">	testSlice1 := slice</span><br><span class="line">	testSlice2 := <span class="built_in">append</span>(<span class="built_in">append</span>(<span class="built_in">append</span>(slice, <span class="number">1</span>), <span class="number">2</span>), <span class="number">3</span>) <span class="comment">// 10,20,1,2，-&gt; 扩容重新分配内存，翻倍 10,20,1,2,3 cap=8</span></span><br><span class="line">	<span class="comment">// 旧切片调整为10,20</span></span><br><span class="line">	slice[<span class="number">0</span>] = <span class="number">11</span> <span class="comment">// slice 还是旧切片， 11,20</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice), slice)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(testSlice1), <span class="built_in">cap</span>(testSlice1), testSlice1)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(testSlice2), <span class="built_in">cap</span>(testSlice2), testSlice2)</span><br><span class="line">	fmt.Println(testSlice1[<span class="number">0</span>])</span><br><span class="line">	fmt.Println(testSlice2[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2 4 [11 20]</span><br><span class="line">2 4 [11 20]</span><br><span class="line">5 8 [10 20 1 2 3]</span><br><span class="line">11</span><br><span class="line">10</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/23/blog/go-http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/23/blog/go-http/" class="post-title-link" itemprop="url">golang http请求</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-23 21:42:23" itemprop="dateCreated datePublished" datetime="2022-01-23T21:42:23+08:00">2022-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-24 10:35:43" itemprop="dateModified" datetime="2022-01-24T10:35:43+08:00">2022-01-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Golang提供了官方的http包，对于http操作非常的方便和简洁。</p>
<h1 id="get-请求"><a href="#get-请求" class="headerlink" title="get 请求"></a>get 请求</h1><p>get请求有好几种方式</p>
<h4 id="直接使用net-http包内的函数请求"><a href="#直接使用net-http包内的函数请求" class="headerlink" title="直接使用net/http包内的函数请求"></a>直接使用<code>net/http</code>包内的函数请求</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line">...</span><br><span class="line">resp, err := http.Get(<span class="string">&quot;http://wwww.baidu.com&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="利用http-client结构体来请求"><a href="#利用http-client结构体来请求" class="headerlink" title="利用http.client结构体来请求"></a>利用http.client结构体来请求</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line">...</span><br><span class="line">clt := http.Client&#123;&#125;</span><br><span class="line">resp, err := clt.Get(<span class="string">&quot;http://wwww.baidu.com&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="最本质的请求方式"><a href="#最本质的请求方式" class="headerlink" title="最本质的请求方式"></a>最本质的请求方式</h4><p>如果稍微看一下源码，就会发现以上两种方式都是用了一下这种最本质的请求方式，使用<code>http.NewRequest</code>函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://www.baidu.com&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后http.client 结构体的 Do 方法</span></span><br><span class="line"><span class="comment">//http.DefaultClient可以换为另外一个http.client</span></span><br><span class="line">resp, err := http.DefaultClient.Do(req)</span><br></pre></td></tr></table></figure>

<p><strong>Go的get请求面上有好几种请求方式，实则只有一种：</strong></p>
<p><strong>1、使用<code>http.NewRequest</code>函数获得<code>request</code>实体</strong></p>
<p><strong>2、利用<code>http.client</code>结构体的<code>Do</code>方法，将<code>request</code>实体传入<code>Do</code>方法中。</strong></p>
<h1 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h1><p>和get请求类似，post请求也有多种方法，<strong>但本质还是使用了<code>http.NewRequest</code>函数和<code>http.client</code>的<code>Do</code>方法。</strong></p>
<h4 id="使用net-http包带的post方法"><a href="#使用net-http包带的post方法" class="headerlink" title="使用net/http包带的post方法"></a>使用<code>net/http</code>包带的post方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;net/url&quot;</span></span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">data := url.Values&#123;<span class="string">&quot;start&quot;</span>:&#123;<span class="string">&quot;0&quot;</span>&#125;, <span class="string">&quot;offset&quot;</span>:&#123;<span class="string">&quot;xxxx&quot;</span>&#125;&#125;</span><br><span class="line">body := strings.NewReader(data.Encode())</span><br><span class="line">resp, err := http.Post(<span class="string">&quot;xxxxxxx&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>, body)</span><br></pre></td></tr></table></figure>

<p>或者还可以</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;net/url&quot;</span></span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> r http.Request</span><br><span class="line">r.ParseForm()</span><br><span class="line">r.Form.Add(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">body := strings.NewReader(r.Form.Encode())</span><br><span class="line">http.Post(<span class="string">&quot;xxxx&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>, body)</span><br></pre></td></tr></table></figure>

<p>要是还是觉得复杂，还可以：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;net/url&quot;</span></span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">data := url.Values&#123;<span class="string">&quot;start&quot;</span>:&#123;<span class="string">&quot;0&quot;</span>&#125;, <span class="string">&quot;offset&quot;</span>:&#123;<span class="string">&quot;xxxx&quot;</span>&#125;&#125;</span><br><span class="line">http.PostForm(<span class="string">&quot;xxxx&quot;</span>, data)</span><br></pre></td></tr></table></figure>

<h4 id="使用实例化的http-client的post方法"><a href="#使用实例化的http-client的post方法" class="headerlink" title="使用实例化的http client的post方法"></a>使用实例化的http client的post方法</h4><p>其实本质上直接使用包的函数和实例化的http client是一样的，包的函数底层也仅仅是实例化了一个<code>DefaultClient</code>，然后调用的<code>DefaultClient</code>的方法。下面给出使用实例化的http client的post方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;net/url&quot;</span></span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">data := url.Values&#123;<span class="string">&quot;start&quot;</span>:&#123;<span class="string">&quot;0&quot;</span>&#125;, <span class="string">&quot;offset&quot;</span>:&#123;<span class="string">&quot;xxxx&quot;</span>&#125;&#125;</span><br><span class="line">body := strings.NewReader(data.Encode())</span><br><span class="line">clt := http.Client&#123;&#125;</span><br><span class="line">resp, err := clt.Post(<span class="string">&quot;xxxxxxx&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>, body)</span><br></pre></td></tr></table></figure>

<p>还有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">var r http.Request</span><br><span class="line">r.ParseForm()</span><br><span class="line">r.Form.Add(&quot;xxx&quot;, &quot;xxx&quot;)</span><br><span class="line">body := strings.NewReader(r.Form.Encode())</span><br><span class="line">clt := http.Client&#123;&#125;</span><br><span class="line">clt.Post(&quot;xxxx&quot;, &quot;application/x-www-form-urlencoded&quot;, body)</span><br></pre></td></tr></table></figure>

<p>简单的，但仅限于form表单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">data := url.Values&#123;&quot;start&quot;:&#123;&quot;0&quot;&#125;, &quot;offset&quot;:&#123;&quot;xxxx&quot;&#125;&#125;</span><br><span class="line">clt := http.Client&#123;&#125;</span><br><span class="line">clt.PostForm(&quot;xxxx&quot;, data)</span><br></pre></td></tr></table></figure>

<h4 id="使用net-http包的NewRequest函数"><a href="#使用net-http包的NewRequest函数" class="headerlink" title="使用net/http包的NewRequest函数"></a>使用<code>net/http</code>包的<code>NewRequest</code>函数</h4><p>其实不管是get方法也好，post方法也好，所有的get、post的的http 请求形式，最终都是会调用<code>net/http</code>包的<code>NewRequest</code>函数，多种多样的请求形式，也仅仅是封装的不同而已。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;net/url&quot;</span></span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">data := url.Values&#123;<span class="string">&quot;start&quot;</span>:&#123;<span class="string">&quot;0&quot;</span>&#125;, <span class="string">&quot;offset&quot;</span>:&#123;<span class="string">&quot;xxxx&quot;</span>&#125;&#125;</span><br><span class="line">body := strings.NewReader(data.Encode())</span><br><span class="line"></span><br><span class="line">req, err := http.NewRequest(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;xxxxx&quot;</span>, body)</span><br><span class="line">req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line"></span><br><span class="line">clt := http.Client&#123;&#125;</span><br><span class="line">clt.Do(req)</span><br></pre></td></tr></table></figure>

<h1 id="添加request-header"><a href="#添加request-header" class="headerlink" title="添加request header"></a>添加request header</h1><p><code>net/http</code>包没有封装直接使用请求带header的get或者post方法，所以，要想请求中带header，只能使用<code>NewRequest</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">req, err := http.NewRequest(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;xxxxx&quot;</span>, body)</span><br><span class="line"><span class="comment">//此处还可以写req.Header.Set(&quot;User-Agent&quot;, &quot;myClient&quot;)</span></span><br><span class="line">req.Header.Add(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;myClient&quot;</span>)</span><br><span class="line"></span><br><span class="line">clt := http.Client&#123;&#125;</span><br><span class="line">clt.Do(req)</span><br></pre></td></tr></table></figure>

<p>有一点需要注意：在添加header操作的时候，<code>req.Header.Add</code>和<code>req.Header.Set</code>都可以，但是在修改操作的时候，只能使用<code>req.Header.Set</code>。<br>这俩方法是有区别的，Golang底层Header的实现是一个<code>map[string][]string</code>，<code>req.Header.Set</code>方法如果原来Header中没有值，那么是没问题的，如果又值，会将原来的值替换掉。而<code>req.Header.Add</code>的话，是在原来值的基础上，再<code>append</code>一个值，例如，原来header的值是“s”，我后<code>req.Header.Add</code>一个”a”的话，变成了<code>[s a]</code>。但是，获取header值的方法<code>req.Header.Get</code>确只取第一个，所以，如果原来有值，重新<code>req.Header.Add</code>一个新值的话，<code>req.Header.Get</code>得到的值不变。</p>
<h1 id="打印response响应"><a href="#打印response响应" class="headerlink" title="打印response响应"></a>打印response响应</h1><p>Golang打印response没有PHP那么爽，哎，编译型语言就是麻烦。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;net/url&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">content, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">respBody := <span class="keyword">string</span>(content)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/22/blog/go%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/22/blog/go%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">go逃逸分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-22 20:50:31" itemprop="dateCreated datePublished" datetime="2022-01-22T20:50:31+08:00">2022-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-24 10:35:43" itemprop="dateModified" datetime="2022-01-24T10:35:43+08:00">2022-01-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>写过C/C++的同学都知道，调用著名的malloc和new函数可以在堆上分配一块内存，这块内存的使用和销毁的责任都在程序员。一不小心，就会发生内存泄露，搞得胆战心惊。</p>
<p>切换到Golang后，基本不会担心内存泄露了。虽然也有new函数，但是使用new函数得到的内存不一定就在堆上。堆和栈的区别对程序员“模糊化”了，当然这一切都是Go编译器在背后帮我们完成的。</p>
<p>一个变量是在堆上分配，还是在栈上分配，是经过编译器的<code>逃逸分析</code>之后得出的结论。</p>
<p>这篇文章，就将带领大家一起去探索<code>逃逸分析</code>——变量到底去哪儿，堆还是栈？</p>
<h2 id="什么是逃逸分析"><a href="#什么是逃逸分析" class="headerlink" title="什么是逃逸分析"></a>什么是逃逸分析</h2><p>以前写C/C++代码时，为了提高效率，常常将<code>pass-by-value</code>（传值）“升级”成<code>pass-by-reference</code>，企图避免构造函数的运行，并且直接返回一个指针。</p>
<p>你一定还记得，这里隐藏了一个很大的坑：在函数内部定义了一个局部变量，然后返回这个局部变量的地址（指针）。这些局部变量是在栈上分配的（静态内存分配），一旦函数执行完毕，变量占据的内存会被销毁，任何对这个返回值作的动作（如解引用），都将扰乱程序的运行，甚至导致程序直接崩溃。比如下面的这段代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">foo</span> <span class="params">( <span class="keyword">void</span> )</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些同学可能知道上面这个坑，用了个更聪明的做法：在函数内部使用new函数构造一个变量（动态内存分配），然后返回此变量的地址。因为变量是在堆上创建的，所以函数退出时不会被销毁。但是，这样就行了吗？new出来的对象该在何时何地delete呢？调用者可能会忘记delete或者直接拿返回值传给其他函数，之后就再也不能delete它了，也就是发生了内存泄露。关于这个坑，大家可以去看看《Effective C++》条款21，讲得非常好！</p>
<p>C++是公认的语法最复杂的语言，据说没有人可以完全掌握C++的语法。而这一切在Go语言中就大不相同了。像上面示例的C++代码放到Go里，没有任何问题。</p>
<p>你表面的光鲜，一定是背后有很多人为你撑起的！Go语言里就是编译器的<code>逃逸分析</code>。它是编译器执行静态代码分析后，对内存管理进行的优化和简化。</p>
<p>在编译原理中，分析指针动态范围的方法称之为<code>逃逸分析</code>。通俗来讲，当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸。</p>
<p>更简单来说，<code>逃逸分析</code>决定一个变量是分配在堆上还是分配在栈上。</p>
<h2 id="为什么要逃逸分析"><a href="#为什么要逃逸分析" class="headerlink" title="为什么要逃逸分析"></a>为什么要逃逸分析</h2><p>前面讲的C/C++中出现的问题，在Go中作为一个语言特性被大力推崇。真是C/C++之砒霜Go之蜜糖！</p>
<p>C/C++中动态分配的内存需要我们手动释放，导致猿们平时在写程序时，如履薄冰。这样做有他的好处：程序员可以完全掌控内存。但是缺点也是很多的：经常出现忘记释放内存，导致内存泄露。所以，很多现代语言都加上了垃圾回收机制。</p>
<p>Go的垃圾回收，让堆和栈对程序员保持透明。真正解放了程序员的双手，让他们可以专注于业务，“高效”地完成代码编写。把那些内存管理的复杂机制交给编译器，而程序员可以去享受生活。</p>
<p><code>逃逸分析</code>这种“骚操作”把变量合理地分配到它该去的地方，“找准自己的位置”。即使你是用new申请到的内存，如果我发现你竟然在退出函数后没有用了，那么就把你丢到栈上，毕竟栈上的内存分配比堆上快很多；反之，即使你表面上只是一个普通的变量，但是经过逃逸分析后发现在退出函数之后还有其他地方在引用，那我就把你分配到堆上。真正地做到“按需分配”，提前实现共产主义！</p>
<p>如果变量都分配到堆上，堆不像栈可以自动清理。它会引起Go频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销（占用CPU容量的25%）。</p>
<p>堆和栈相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。栈内存分配则会非常快。栈分配内存只需要两个CPU指令：“PUSH”和“RELEASE”，分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。</p>
<p>通过逃逸分析，可以尽量把那些不需要分配到堆上的变量直接分配到栈上，堆上的变量少了，会减轻分配堆内存的开销，同时也会减少gc的压力，提高程序的运行速度。</p>
<h2 id="逃逸分析是怎么完成的"><a href="#逃逸分析是怎么完成的" class="headerlink" title="逃逸分析是怎么完成的"></a>逃逸分析是怎么完成的</h2><p>Go逃逸分析最基本的原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸。</p>
<p>简单来说，编译器会分析代码的特征和代码生命周期，Go中的变量只有在编译器可以证明在函数返回后不会再被引用的，才分配到栈上，其他情况下都是分配到堆上。</p>
<p>Go语言里没有一个关键字或者函数可以直接让变量被编译器分配到堆上，相反，编译器通过分析代码来决定将变量分配到何处。</p>
<p>对一个变量取地址，可能会被分配到堆上。但是编译器进行逃逸分析后，如果考察到在函数返回后，此变量不会被引用，那么还是会被分配到栈上。套个取址符，就想骗补助？Too young！</p>
<p><strong>简单来说，编译器会根据变量是否被外部引用来决定是否逃逸：</strong></p>
<ol>
<li> <strong>如果函数外部没有引用，则优先放到栈中；</strong></li>
<li> <strong>如果函数外部存在引用，则必定放到堆中；</strong></li>
</ol>
<p>针对第一条，可能放到堆上的情形：定义了一个很大的数组，需要申请的内存过大，超过了栈的存储能力。</p>
<h2 id="逃逸分析实例"><a href="#逃逸分析实例" class="headerlink" title="逃逸分析实例"></a>逃逸分析实例</h2><p>Go提供了相关的命令，可以查看变量是否发生逃逸。</p>
<p>还是用上面我们提到的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">    t := <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> &amp;t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := foo()</span><br><span class="line">    fmt.Println(*x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>foo函数返回一个局部变量的指针，main函数里变量x接收它。执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags &#x27;-m -l&#x27; main.go</span><br></pre></td></tr></table></figure>

<p>加<code>-l</code>是为了不让foo函数被内联。得到如下输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> command-line-arguments</span></span><br><span class="line">src/main.go:7:9: &amp;t escapes to heap</span><br><span class="line">src/main.go:6:7: moved to heap: t</span><br><span class="line">src/main.go:12:14: *x escapes to heap</span><br><span class="line">src/main.go:12:13: main ... argument does not escape</span><br></pre></td></tr></table></figure>

<p>foo函数里的变量<code>t</code>逃逸了，和我们预想的一致。让我们不解的是为什么main函数里的<code>x</code>也逃逸了？这是因为有些函数参数为interface类型，比如fmt.Println(a …interface{})，编译期间很难确定其参数的具体类型，也会发生逃逸。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>堆上动态分配内存比栈上静态分配内存，开销大很多。</p>
<p>变量分配在栈上需要能在编译期确定它的作用域，否则会分配到堆上。</p>
<p>Go编译器会在编译期对考察变量的作用域，并作一系列检查，如果它的作用域在运行期间对编译器一直是可知的，那么就会分配到栈上。</p>
<p>简单来说，编译器会根据变量是否被外部引用来决定是否逃逸。对于Go程序员来说，编译器的这些逃逸分析规则不需要掌握，我们只需通过<code>go build -gcflags &#39;-m&#39;</code>命令来观察变量逃逸情况就行了。</p>
<p>不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作。但其实当参数为变量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多。</p>
<p>最后，尽量写出少一些逃逸的代码，提升程序的运行效率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/22/blog/go-stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/22/blog/go-stack/" class="post-title-link" itemprop="url">golang栈stack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-22 20:50:31" itemprop="dateCreated datePublished" datetime="2022-01-22T20:50:31+08:00">2022-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-24 14:16:49" itemprop="dateModified" datetime="2022-01-24T14:16:49+08:00">2022-01-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>有些程序员也把栈称为堆栈, 即栈和堆栈是同一个概念</p>
<ol>
<li>栈的英文为(stack)</li>
<li>栈是一个先入后出(FILO-First In Last Out)的有序列表。</li>
<li>栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。</li>
<li>根据堆栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</li>
</ol>
<h2 id="1-1-示意图"><a href="#1-1-示意图" class="headerlink" title="1.1. 示意图"></a>1.1. 示意图</h2><p>入栈</p>
<p><img src="https://www.guaosi.com/assets/blogImg/data-structures-and-algorithms/stack/push-stack.png" alt="push-stack"></p>
<p>出栈</p>
<p><img src="https://www.guaosi.com/assets/blogImg/data-structures-and-algorithms/stack/pop-stack.png" alt="pop-stack"></p>
<h2 id="1-2-场景"><a href="#1-2-场景" class="headerlink" title="1.2. 场景"></a>1.2. 场景</h2><ol>
<li>子程序的调用:在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再 将地址取出，以回到原来的程序中。</li>
<li>处理递归调用:和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变 量等数据存入堆栈中。</li>
<li>表达式的转换与求值。</li>
<li>二叉树的遍历。</li>
<li>图形的深度优先(depth 一 first)搜索法。</li>
</ol>
<h2 id="1-3-案例"><a href="#1-3-案例" class="headerlink" title="1.3. 案例"></a>1.3. 案例</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;</span><br><span class="line">	maxNum <span class="keyword">int</span>    <span class="comment">//规定栈最多放几个元素</span></span><br><span class="line">	top    <span class="keyword">int</span>    <span class="comment">//目前栈顶的下标</span></span><br><span class="line">	arr    [<span class="number">5</span>]<span class="keyword">int</span> <span class="comment">//模拟栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stack)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> this.isFull() &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;stack full&quot;</span>)</span><br><span class="line">		err = errors.New(<span class="string">&quot;stack full&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//开始入栈操作</span></span><br><span class="line">	<span class="comment">//先向上走一步</span></span><br><span class="line">	this.top++</span><br><span class="line">	<span class="comment">//再赋值</span></span><br><span class="line">	this.arr[this.top] = val</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="params">(val <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> this.isEmpty() &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;stack empty&quot;</span>)</span><br><span class="line">		err = errors.New(<span class="string">&quot;stack empty&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	val = this.arr[this.top]</span><br><span class="line">	this.top--</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stack)</span> <span class="title">List</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> this.isEmpty() &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;stack empty&quot;</span>)</span><br><span class="line">		err = errors.New(<span class="string">&quot;stack empty&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := this.top; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>, i, this.arr[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stack)</span> <span class="title">isFull</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.top+<span class="number">1</span> &gt;= this.maxNum</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stack)</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.top == <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> stack = &amp;Stack&#123;</span><br><span class="line">		maxNum: <span class="number">5</span>,</span><br><span class="line">		top:    <span class="number">-1</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	stack.Push(<span class="number">1</span>)</span><br><span class="line">	stack.Push(<span class="number">2</span>)</span><br><span class="line">	stack.Push(<span class="number">3</span>)</span><br><span class="line">	stack.Push(<span class="number">4</span>)</span><br><span class="line">	stack.Push(<span class="number">5</span>)</span><br><span class="line">	stack.List()</span><br><span class="line"></span><br><span class="line">	val, _ := stack.Pop()</span><br><span class="line">	fmt.Println(<span class="string">&quot;弹出 &quot;</span>, val)</span><br><span class="line">	stack.List()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-栈的计算表达式"><a href="#1-4-栈的计算表达式" class="headerlink" title="1.4. 栈的计算表达式"></a>1.4. 栈的计算表达式</h2><h3 id="1-4-1-分析"><a href="#1-4-1-分析" class="headerlink" title="1.4.1. 分析"></a>1.4.1. 分析</h3><p><img src="https://www.guaosi.com/assets/blogImg/data-structures-and-algorithms/stack/exp%E5%88%86%E6%9E%90.png" alt="exp分析"></p>
<h3 id="1-4-2-实现"><a href="#1-4-2-实现" class="headerlink" title="1.4.2. 实现"></a>1.4.2. 实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;</span><br><span class="line">	maxNum <span class="keyword">int</span>     <span class="comment">//规定栈最多放几个元素</span></span><br><span class="line">	top    <span class="keyword">int</span>     <span class="comment">//目前栈顶的下标</span></span><br><span class="line">	arr    [<span class="number">20</span>]<span class="keyword">int</span> <span class="comment">//模拟栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stack)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> this.isFull() &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;stack full&quot;</span>)</span><br><span class="line">		err = errors.New(<span class="string">&quot;stack full&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//开始入栈操作</span></span><br><span class="line">	<span class="comment">//先向上走一步</span></span><br><span class="line">	this.top++</span><br><span class="line">	<span class="comment">//再赋值</span></span><br><span class="line">	this.arr[this.top] = val</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="params">(val <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> this.isEmpty() &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;stack empty&quot;</span>)</span><br><span class="line">		err = errors.New(<span class="string">&quot;stack empty&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	val = this.arr[this.top]</span><br><span class="line">	this.top--</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stack)</span> <span class="title">List</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> this.isEmpty() &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;stack empty&quot;</span>)</span><br><span class="line">		err = errors.New(<span class="string">&quot;stack empty&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := this.top; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>, i, this.arr[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stack)</span> <span class="title">isFull</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.top+<span class="number">1</span> &gt;= this.maxNum</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stack)</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.top == <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是不是运算符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stack)</span> <span class="title">isOper</span><span class="params">(oper <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> oper == <span class="number">42</span> || oper == <span class="number">43</span> || oper == <span class="number">45</span> || oper == <span class="number">47</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stack)</span> <span class="title">cal</span><span class="params">(num1, num2, oper <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">//因为栈是先进后出，所以num2应该是第一个数，num1是第二个数</span></span><br><span class="line">	<span class="keyword">switch</span> oper &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">42</span>:</span><br><span class="line">		<span class="keyword">return</span> num2 * num1</span><br><span class="line">	<span class="keyword">case</span> <span class="number">43</span>:</span><br><span class="line">		<span class="keyword">return</span> num2 + num1</span><br><span class="line">	<span class="keyword">case</span> <span class="number">45</span>:</span><br><span class="line">		<span class="keyword">return</span> num2 - num1</span><br><span class="line">	<span class="keyword">case</span> <span class="number">47</span>:</span><br><span class="line">		<span class="keyword">return</span> num2 / num1</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;运算符错误&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回优先级</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Stack)</span> <span class="title">Priority</span><span class="params">(oper <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> oper == <span class="number">42</span> || oper == <span class="number">47</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> oper == <span class="number">43</span> || oper == <span class="number">45</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	numStack := &amp;Stack&#123; <span class="comment">//数栈</span></span><br><span class="line">		maxNum: <span class="number">20</span>,</span><br><span class="line">		top:    <span class="number">-1</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	operStack := &amp;Stack&#123; <span class="comment">//运算符栈</span></span><br><span class="line">		maxNum: <span class="number">20</span>,</span><br><span class="line">		top:    <span class="number">-1</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	exp := <span class="string">&quot;300+600*2-18*5&quot;</span></span><br><span class="line">	exp_len := <span class="built_in">len</span>(exp)</span><br><span class="line">	num1 := <span class="number">0</span></span><br><span class="line">	num2 := <span class="number">0</span></span><br><span class="line">	oper := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> num_str <span class="keyword">string</span></span><br><span class="line">	<span class="comment">//将表达式入栈并且进行计算</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; exp_len; i++ &#123;</span><br><span class="line">		ch := <span class="keyword">int</span>(exp[i]) <span class="comment">//返回的是asiic码值</span></span><br><span class="line">		<span class="keyword">if</span> operStack.isOper(ch) &#123;</span><br><span class="line">			<span class="comment">//如果放进去的是运算符</span></span><br><span class="line">			<span class="comment">//需要先考虑是不是第一个元素</span></span><br><span class="line">			<span class="keyword">if</span> operStack.isEmpty() &#123;</span><br><span class="line">				<span class="comment">//如果是空，代表第一个元素，直接入栈</span></span><br><span class="line">				operStack.Push(ch)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//如果不是第一个元素，则需要考虑，此时栈顶元素的优先级是否大于等于当前想要入栈的值</span></span><br><span class="line">				<span class="keyword">if</span> operStack.Priority(operStack.arr[operStack.top]) &gt;= operStack.Priority(ch) &#123;</span><br><span class="line">					<span class="comment">//无需担心数量是否不匹配，只要表达式正确，数量一定没问题</span></span><br><span class="line">					<span class="comment">//从数栈中弹出2个</span></span><br><span class="line">					num1, _ = numStack.Pop()</span><br><span class="line">					num2, _ = numStack.Pop()</span><br><span class="line">					<span class="comment">//运算符栈弹出一个</span></span><br><span class="line">					oper, _ = operStack.Pop()</span><br><span class="line"></span><br><span class="line">					<span class="comment">//运算结果入数栈（这里num1,num2顺序不能错乱，因为是先进后出）</span></span><br><span class="line">					numStack.Push(numStack.cal(num1, num2, oper))</span><br><span class="line">					<span class="comment">//运算符入运算符栈</span></span><br><span class="line">					operStack.Push(ch)</span><br><span class="line"></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//不成立的话，证明运算符级别相同，直接入栈</span></span><br><span class="line">					operStack.Push(ch)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//如果放进去的是数字</span></span><br><span class="line">			<span class="comment">//此时需要考虑，数字有几位数</span></span><br><span class="line">			<span class="comment">//数字是否是最后一位</span></span><br><span class="line">			temp := i</span><br><span class="line">			num_str = <span class="keyword">string</span>(ch) <span class="comment">//将asiic用string强转，返回的是对应的字符</span></span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> temp+<span class="number">1</span> != exp_len &amp;&amp; !operStack.isOper(<span class="keyword">int</span>(exp[temp+<span class="number">1</span>])) &#123;</span><br><span class="line">					<span class="comment">//如果下一位既不是字符串最后一个或者不是运算符</span></span><br><span class="line">					<span class="comment">//那么就加入到num_str,累计字符串</span></span><br><span class="line">					num_str += <span class="keyword">string</span>(exp[temp+<span class="number">1</span>])</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//否则就是不符合，直接退出</span></span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				temp++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//将拼接后的字符串转为数字</span></span><br><span class="line">			num, _ := strconv.Atoi(num_str)</span><br><span class="line">			<span class="comment">//是数字就不需要考虑，直接入栈</span></span><br><span class="line">			numStack.Push(num)</span><br><span class="line">			<span class="comment">//同时，让for循环走到temp的位置</span></span><br><span class="line">			i = temp</span><br><span class="line">			<span class="comment">//清空内容</span></span><br><span class="line">			num_str = <span class="string">&quot;&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将栈内剩余的表达式再进行运算</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> operStack.isEmpty() &#123;</span><br><span class="line">			<span class="comment">//如果运算符为空，证明全部计算完成，直接退出</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//否则进行计算</span></span><br><span class="line"></span><br><span class="line">		num1, _ = numStack.Pop()</span><br><span class="line">		num2, _ = numStack.Pop()</span><br><span class="line">		<span class="comment">//运算符栈弹出一个</span></span><br><span class="line">		oper, _ = operStack.Pop()</span><br><span class="line"></span><br><span class="line">		<span class="comment">//运算结果入数栈（这里num1,num2顺序不能错乱，因为是先进后出）</span></span><br><span class="line">		numStack.Push(numStack.cal(num1, num2, oper))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//全部计算完成，弹出numStack就是结果</span></span><br><span class="line">	result, _ := numStack.Pop()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s = %v \n&quot;</span>, exp, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/22/blog/golang%E5%9D%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/22/blog/golang%E5%9D%91/" class="post-title-link" itemprop="url">golang坑</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-22 15:44:43" itemprop="dateCreated datePublished" datetime="2022-01-22T15:44:43+08:00">2022-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-24 10:35:43" itemprop="dateModified" datetime="2022-01-24T10:35:43+08:00">2022-01-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Golang是一门语言，它简洁、高效、易学习、开发效率高、还可以编译成机器码…<br>它毕竟是一门新兴语言，一边学习，一边踩坑。</p>
<h1 id="多个defer出现的时候，多个defer之间按照LIFO（后进先出）的顺序执行"><a href="#多个defer出现的时候，多个defer之间按照LIFO（后进先出）的顺序执行" class="headerlink" title="多个defer出现的时候，多个defer之间按照LIFO（后进先出）的顺序执行"></a>多个<code>defer</code>出现的时候，多个<code>defer</code>之间按照LIFO（后进先出）的顺序执行</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h1 id="用for-range来遍历数组或者map的时候，被遍历的指针是不变的，每次遍历仅执行struct值的拷贝"><a href="#用for-range来遍历数组或者map的时候，被遍历的指针是不变的，每次遍历仅执行struct值的拷贝" class="headerlink" title="用for range来遍历数组或者map的时候，被遍历的指针是不变的，每次遍历仅执行struct值的拷贝"></a>用<code>for range</code>来遍历数组或者map的时候，<u><em>被遍历的指针是不变的，每次遍历仅执行struct值的拷贝</em></u></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stus []student</span><br><span class="line"></span><br><span class="line">    stus = []student&#123;</span><br><span class="line">        &#123;Name:<span class="string">&quot;one&quot;</span>, Age: <span class="number">18</span>&#125;,</span><br><span class="line">        &#123;Name:<span class="string">&quot;two&quot;</span>, Age: <span class="number">19</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*student)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> stus&#123;</span><br><span class="line">        data[i] = &amp;v   <span class="comment">//应该改为：data[i] = &amp;stus[i]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> data&#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;key=%d, value=%v \n&quot;</span>, i,v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，结果输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key=0, value=&amp;&#123;two 19&#125; </span><br><span class="line">key=1, value=&amp;&#123;two 19&#125;</span><br></pre></td></tr></table></figure>

<h1 id="不管运行顺序如何，当参数为函数的时候，要先计算参数的值"><a href="#不管运行顺序如何，当参数为函数的时候，要先计算参数的值" class="headerlink" title="不管运行顺序如何，当参数为函数的时候，要先计算参数的值"></a>不管运行顺序如何，当参数为函数的时候，要先计算参数的值</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">print</span>(function(a))</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(num <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h1 id="make-chan-int-和-make-chan-int-1-是不一样的"><a href="#make-chan-int-和-make-chan-int-1-是不一样的" class="headerlink" title="make(chan int) 和 make(chan int, 1)是不一样的"></a><code>make(chan int)</code> 和 <code>make(chan int, 1)</code>是不一样的</h1><p><code>chan</code>一旦被写入数据后，当前<code>goruntine</code>就会被阻塞，知道有人接收才可以（即 “ &lt;- ch”），如果没人接收，它就会一直阻塞着。而如果chan带一个缓冲，就会把数据放到缓冲区中，直到缓冲区满了，才会阻塞</p>
<p>非缓冲channel和缓冲channel</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//改为 ch := make(chan int, 1) 就好了</span></span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure>

<h1 id="golang-的-select-的功能和-select-poll-epoll-相似，-就是监听-IO-操作，当-IO-操作发生时，触发相应的动作。"><a href="#golang-的-select-的功能和-select-poll-epoll-相似，-就是监听-IO-操作，当-IO-操作发生时，触发相应的动作。" class="headerlink" title="golang 的 select 的功能和 select, poll, epoll 相似， 就是监听 IO 操作，当 IO 操作发生时，触发相应的动作。"></a>golang 的 select 的功能和 select, poll, epoll 相似， 就是监听 IO 操作，当 IO 操作发生时，触发相应的动作。</h1><p>select 的代码形式和 switch 非常相似， 不过 select 的 case 里的操作语句只能是”IO操作”（不仅仅是取值<code>&lt;-channel</code>，赋值<code>channel&lt;-</code>也可以）， select 会一直等待等到某个 case 语句完成，也就是等到成功从channel中读到数据。 则 select 语句结束</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg :=&lt;-ch:</span><br><span class="line">        fmt.Println(msg)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<p><code>default</code>可以判断chan是否已经满了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg :=&lt;-ch:</span><br><span class="line">        fmt.Println(msg)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<p>此时因为<code>ch</code>中没有写入数据，为空，所以 case不会读取成功。 则 select 执行 default 语句。</p>
<h1 id="Go语言中不存在未初始化的变量"><a href="#Go语言中不存在未初始化的变量" class="headerlink" title="Go语言中不存在未初始化的变量"></a>Go语言中不存在未初始化的变量</h1><p>变量定义基本方式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 变量名字 类型 = 表达式</span><br></pre></td></tr></table></figure>

<p>其中类型和表达式均可省略，如果初始化表达式被省略，将用零值初始化该变量。</p>
<ul>
<li>  数值变量对应的是0值</li>
<li>  布尔变量对应的是false</li>
<li>  字符串对应的零值是空字符串</li>
<li>  接口或者引用类型（包括slice，map，chan）变量对应的是nil</li>
<li>  数组或者结构体等聚合类型对应的零值是每个元素或字段对应该类型的零值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s string </span><br><span class="line">fmt.Println(s) // &quot;&quot;</span><br></pre></td></tr></table></figure>

<h1 id="注意的问题"><a href="#注意的问题" class="headerlink" title=":=注意的问题"></a><code>:=</code>注意的问题</h1><ul>
<li><p>  使用<code>:=</code>定义的变量，仅能使用在函数内部。</p>
</li>
<li><p>在定义多个变量的时候</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:=</span><br></pre></td></tr></table></figure>

<p>  周围不一定是全部都是刚刚声明的，有些可能只是赋值，例如下面的err变量</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in, err := os.Open(infile)</span><br><span class="line"><span class="comment">// TODO</span></span><br><span class="line">out, err := os.Create(outfile)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="new在Go语言中只是一个预定义的函数，它并不是一个关键字，我们可以将new作为变量或者其他"><a href="#new在Go语言中只是一个预定义的函数，它并不是一个关键字，我们可以将new作为变量或者其他" class="headerlink" title="new在Go语言中只是一个预定义的函数，它并不是一个关键字，我们可以将new作为变量或者其他"></a><code>new</code>在Go语言中只是一个预定义的函数，它并不是一个关键字，我们可以将<code>new</code>作为变量或者其他</h1><p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func delta(old, new int) int &#123; </span><br><span class="line">    return new - old </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是正确的。</p>
<h1 id="并不是使用new就一定会在堆上分配内存"><a href="#并不是使用new就一定会在堆上分配内存" class="headerlink" title="并不是使用new就一定会在堆上分配内存"></a>并不是使用<code>new</code>就一定会在堆上分配内存</h1><p>编译器会自动选择在栈上还是在堆上分配存储空间，但可能令人惊讶的是，这个选择并不是由用<code>var</code>还是<code>new</code>声明变量的方式决定的。</p>
<p>请看例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global *<span class="keyword">int</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span> x=<span class="number">1</span> </span><br><span class="line">    global = &amp;x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">    y := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">    *y = <span class="number">1</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>f()</code>函数中的<code>x</code>就是在堆上分配内存，而<code>g()</code>函数中的<code>y</code>就是分配在栈上。</p>
<h1 id="init函数在同一个文件中可以包含多个"><a href="#init函数在同一个文件中可以包含多个" class="headerlink" title="init函数在同一个文件中可以包含多个"></a><code>init</code>函数在同一个文件中可以包含多个</h1><p>在同一个包文件中，可以包含有多个<code>init</code>函数，<strong>多个<code>init</code>函数的执行顺序和定义顺序（导入递归顺序）一致</strong>。</p>
<h1 id="Golang中没有“对象”"><a href="#Golang中没有“对象”" class="headerlink" title="Golang中没有“对象”"></a>Golang中没有“对象”</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *test)</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t *test</span><br><span class="line">    t = <span class="literal">nil</span></span><br><span class="line">    t.getName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能正常输出吗？会报错吗？</p>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>可以正常输出。Go本质上不是面向对象的语言，Go中是不存在object的含义的，Go语言书籍中的对象也和Java、PHP中的对象有区别，不是真正的”对象”，是Go中struct的实体。</p>
<p>调用getName方法，在Go中还可以转换，转换为：Type.method(t Type, arguments)<br>所以，以上代码main函数中还可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    (*test).getName(nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Go中的指针-符号的含义"><a href="#Go中的指针-符号的含义" class="headerlink" title="Go中的指针*符号的含义"></a>Go中的指针<code>*</code>符号的含义</h1><p>&amp;的意思大家都明白的，取地址，假如你想获得一个变量的地址，只需在变量前加上&amp;即可。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := 1</span><br><span class="line">b := &amp;a</span><br></pre></td></tr></table></figure>

<p>现在，我拿到a的地址了，但是我想取得a指针指向的值，该如何操作呢？用<code>*</code>号，<code>*b</code>即可。<br>*的意思是对指针取值。</p>
<p>下面对a的值加一</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := 1</span><br><span class="line">b := &amp;a</span><br><span class="line">*b++</span><br></pre></td></tr></table></figure>

<p><code>*</code>和<code>&amp;</code>可以相互抵消，同时注意，<code>*&amp;</code>可以抵消，但是<code>&amp;*</code>不可以；所以<code>a</code>和<code>*&amp;a</code>是一样的，和<code>*&amp;*&amp;*&amp;a</code>也是一样的。</p>
<h1 id="os-Args获取命令行指令参数，应该从数组的1坐标开始"><a href="#os-Args获取命令行指令参数，应该从数组的1坐标开始" class="headerlink" title="os.Args获取命令行指令参数，应该从数组的1坐标开始"></a><code>os.Args</code>获取命令行指令参数，应该从数组的1坐标开始</h1><p><code>os.Args</code>的第一个元素，<code>os.Args[0]</code>, 是命令本身的名字</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(os.Args[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，经过<code>go build</code>之后，打包成一个可执行文件<code>main</code>，然后运行指令<code>./main 123</code></p>
<p>输出：<code>./main</code></p>
<h1 id="数组切片slice的容量问题带来的bug"><a href="#数组切片slice的容量问题带来的bug" class="headerlink" title="数组切片slice的容量问题带来的bug"></a>数组切片slice的容量问题带来的bug</h1><p>请看下列代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    array := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">    slice := array[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    newSlice := <span class="built_in">append</span>(slice, <span class="number">50</span>)</span><br><span class="line">    newSlice[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">    fmt.Println(slice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问输出什么?<br>答案是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[10 21]</span><br></pre></td></tr></table></figure>

<p>如果稍作修改，将以上newSlice改为扩容三次，newSlice := append(append(append(slice, 50), 100), 150)如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    array := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">    slice := array[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    newSlice := <span class="built_in">append</span>(<span class="built_in">append</span>(<span class="built_in">append</span>(slice, <span class="number">50</span>), <span class="number">100</span>), <span class="number">150</span>)</span><br><span class="line">    newSlice[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">    fmt.Println(slice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[10 20]</span><br></pre></td></tr></table></figure>

<p>这特么是什么鬼？<br>这就要从Golang切片的扩容说起了；切片的扩容，就是当切片添加元素时，切片容量不够了，就会扩容，扩容的大小遵循下面的原则：（如果切片的容量小于1024个元素，那么扩容的时候slice的cap就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一。）如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组（这就是产生bug的原因）；如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组。<br>建议尽量避免bug的产生。</p>
<h1 id="map引用不存在的key，不报错"><a href="#map引用不存在的key，不报错" class="headerlink" title="map引用不存在的key，不报错"></a><code>map</code>引用不存在的key，不报错</h1><p>请问下面的例子输出什么，会报错吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    newMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    fmt.Println(newMap[<span class="string">&quot;a&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

<p>不报错。不同于PHP，Golang的map和Java的HashMap类似，Java引用不存在的会返回null，而Golang会返回初始值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v,ok := newMap[<span class="string">&quot;a&quot;</span>];ok &#123;</span><br><span class="line">	<span class="comment">// do</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="map使用range遍历顺序问题，并不是录入的顺序，而是随机顺序"><a href="#map使用range遍历顺序问题，并不是录入的顺序，而是随机顺序" class="headerlink" title="map使用range遍历顺序问题，并不是录入的顺序，而是随机顺序"></a>map使用range遍历顺序问题，并不是录入的顺序，而是随机顺序</h1><p>请看下面的例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    newMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++&#123;</span><br><span class="line">        newMap[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> key, value := <span class="keyword">range</span> newMap&#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;key is %d, value is %d\n&quot;</span>, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">key is 1, value is 1</span><br><span class="line">key is 3, value is 3</span><br><span class="line">key is 5, value is 5</span><br><span class="line">key is 7, value is 7</span><br><span class="line">key is 9, value is 9</span><br><span class="line">key is 0, value is 0</span><br><span class="line">key is 2, value is 2</span><br><span class="line">key is 4, value is 4</span><br><span class="line">key is 6, value is 6</span><br><span class="line">key is 8, value is 8</span><br></pre></td></tr></table></figure>

<p>是杂乱无章的顺序。map的遍历顺序不固定，这种设计是有意为之的，能为能防止程序依赖特定遍历顺序。</p>
<p>如果想按顺序排序，可以进行key排序，然后再输出。</p>
<h1 id="channel作为函数参数传递，可以声明为只取-lt-chan-或者只发送-chan-lt"><a href="#channel作为函数参数传递，可以声明为只取-lt-chan-或者只发送-chan-lt" class="headerlink" title="channel作为函数参数传递，可以声明为只取(&lt;- chan)或者只发送(chan &lt;-)"></a>channel作为函数参数传递，可以声明为只取(&lt;- chan)或者只发送(chan &lt;-)</h1><p>一个函数在将channel作为一个类型的参数来声明的时候，可以将channl声明为只可以取值(&lt;- chan)或者只可以发送值(chan &lt;-)，不特殊说明，则既可以取值，也可以发送值。</p>
<p>例如：只可以发送值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setData</span><span class="params">(ch <span class="keyword">chan</span> &lt;- <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在以上函数中存在&lt;-ch则会编译不通过。</p>
<p>如下是只可以取值:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setData</span><span class="params">(ch &lt;- <span class="keyword">chan</span>  <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果以上函数中存在ch&lt;-则在编译期会报错</p>
<h1 id="使用channel时，注意goroutine之间的执行流程问题"><a href="#使用channel时，注意goroutine之间的执行流程问题" class="headerlink" title="使用channel时，注意goroutine之间的执行流程问题"></a>使用channel时，注意goroutine之间的执行流程问题</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> setData(ch)</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setData</span><span class="params">(ch  <span class="keyword">chan</span>  <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    ch &lt;- <span class="string">&quot;test&quot;</span></span><br><span class="line">    ch &lt;- <span class="string">&quot;hello wolrd&quot;</span></span><br><span class="line">    ch &lt;- <span class="string">&quot;123&quot;</span></span><br><span class="line">    ch &lt;- <span class="string">&quot;456&quot;</span></span><br><span class="line">    ch &lt;- <span class="string">&quot;789&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的执行流程是怎样的呢？<br>一个基于无缓存channel的发送或者取值操作，会导致当前goroutine阻塞，一直等待到另外的一个goroutine做相反的取值或者发送操作以后，才会正常跑。<br>以上例子中的流程是这样的：</p>
<p>主goroutine等待接收，另外的那一个goroutine发送了“test”并等待处理；完成通信后，打印出”test”；两个goroutine各自继续跑自己的。<br>主goroutine等待接收，另外的那一个goroutine发送了“hello world”并等待处理；完成通信后，打印出”hello world”；两个goroutine各自继续跑自己的。<br>主goroutine等待接收，另外的那一个goroutine发送了“123”并等待处理；完成通信后，打印出”123”；两个goroutine各自继续跑自己的。<br>主goroutine等待接收，另外的那一个goroutine发送了“456”并等待处理；完成通信后，打印出”456”；两个goroutine各自继续跑自己的。<br>主goroutine等待接收，另外的那一个goroutine发送了“789”并等待处理；完成通信后，打印出”789”；两个goroutine各自继续跑自己的。</p>
<p>记住：Golang的channel是用来goroutine之间通信的，且通信过程中会阻塞。</p>
<h1 id="Golang中函数被看做是值-函数值不可以比较，也不可以作为map的key"><a href="#Golang中函数被看做是值-函数值不可以比较，也不可以作为map的key" class="headerlink" title="Golang中函数被看做是值,函数值不可以比较，也不可以作为map的key"></a>Golang中函数被看做是值,函数值不可以比较，也不可以作为map的key</h1><p>请问以下代码能编译通过吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	array := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="function"><span class="keyword">func</span> <span class="params">()</span><span class="title">int</span>)</span></span><br><span class="line"></span><br><span class="line">	array[<span class="function"><span class="keyword">func</span><span class="params">()</span><span class="title">int</span></span>&#123; <span class="keyword">return</span> <span class="number">10</span>&#125;()] = <span class="function"><span class="keyword">func</span><span class="params">()</span><span class="title">int</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">12</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以正常编译通过。</span><br></pre></td></tr></table></figure>

<p>稍作改动，改为如下的情况,还能编译通过吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	array := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="function"><span class="keyword">func</span> <span class="params">()</span><span class="title">int</span>]<span class="title">int</span>)</span></span><br><span class="line"></span><br><span class="line">	array[<span class="function"><span class="keyword">func</span><span class="params">()</span><span class="title">int</span></span>&#123;<span class="keyword">return</span> <span class="number">12</span>&#125;] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不能编译通过。</span><br></pre></td></tr></table></figure>

<p>在Go语言中，函数被看做是第一类值：(first-class values)：函数和其他值一样，可以被赋值，可以传递给函数，可以从函数返回。也可以被当做是一种“函数类型”。例如：有函数<code>func square(n int) int &#123; return n * n &#125;</code>，那么就可以赋值<code>f := square</code>,而且还可以<code>fmt.Println(f(3))</code>（将打印出“9”）。<br>Go语言函数有两点很特别：</p>
<ul>
<li>  <strong>函数值类型不能作为map的key</strong></li>
<li>  <strong>函数值之间不可以比较，函数值只可以和nil作比较，函数类型的零值是<code>nil</code></strong></li>
</ul>
<h1 id="匿名函数作用域陷阱"><a href="#匿名函数作用域陷阱" class="headerlink" title="匿名函数作用域陷阱"></a>匿名函数作用域陷阱</h1><p>请看下列代码输出什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> msgs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	array := []<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, e := <span class="keyword">range</span> array&#123;</span><br><span class="line"></span><br><span class="line">		msgs = <span class="built_in">append</span>(msgs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">			fmt.Println(e)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> msgs&#123;</span><br><span class="line">		v()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<strong>匿名函数中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。</strong></p>
<p>想要输出1、2、3、4需要改为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> msgs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	array := []<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, e := <span class="keyword">range</span> array&#123;</span><br><span class="line">		elem := e</span><br><span class="line">		msgs = <span class="built_in">append</span>(msgs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">			fmt.Println(elem)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> msgs&#123;</span><br><span class="line">		v()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就加了条<code>elem := e</code>看似多余，其实不，这样一来，每次循环后每个匿名函数中保存的就都是当时局部变量<code>elem</code>的值，这样的局部变量定义了4个，每次循环生成一个。</p>
<h1 id="3-int-和-4-int-不算同一个类型"><a href="#3-int-和-4-int-不算同一个类型" class="headerlink" title="[3]int 和 [4]int 不算同一个类型"></a><code>[3]int</code> 和 <code>[4]int</code> 不算同一个类型</h1><p>请看一下代码，请问输出<code>true</code>还是<code>false</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    arrayA := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    arrayB := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(reflect.TypeOf(arrayA) == reflect.TypeOf(arrayB))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>

<p><strong>数组长度是数组类型的一个组成部分</strong>，因此[3]int和[4]int是两种不同的数组类型。</p>
<h1 id="数组还可以指定一个索引和对应值的方式来初始化。"><a href="#数组还可以指定一个索引和对应值的方式来初始化。" class="headerlink" title="数组还可以指定一个索引和对应值的方式来初始化。"></a>数组还可以指定一个索引和对应值的方式来初始化。</h1><p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    arrayA := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">1</span>, <span class="number">3</span>:<span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(arrayA)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1 0 1 4]</span><br></pre></td></tr></table></figure>

<p>有点像<code>PHP</code>数组的感觉，但是又不一样：<code>arrayA</code>的长度是多少呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    arrayA := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">1</span>, <span class="number">3</span>:<span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(arrayA))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>没错，定义了一个数组长度为4的数组，指定索引的数组长度和最后一个索引的数值相关，例如:<code>r := [...]int&#123;99:-1&#125;</code>就定义了一个含有100个元素的数组<code>r</code>，最后一个元素输出化为-1，其他的元素都是用0初始化。</p>
<h1 id="不能对map中的某个元素进行取地址-amp-操作"><a href="#不能对map中的某个元素进行取地址-amp-操作" class="headerlink" title="不能对map中的某个元素进行取地址&amp;操作"></a>不能对map中的某个元素进行取地址<code>&amp;</code>操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := &amp;ages[&quot;bob&quot;] // compile error: cannot take address of map element</span><br></pre></td></tr></table></figure>

<p><strong>map中的元素不是一个变量，不能对map的元素进行取地址操作，</strong>禁止对map进行取地址操作的原因可能是map随着元素的增加map可能会重新分配内存空间，这样会导致原来的地址无效</p>
<h1 id="当map为nil的时候，不能添加值"><a href="#当map为nil的时候，不能添加值" class="headerlink" title="当map为nil的时候，不能添加值"></a>当map为nil的时候，不能添加值</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sampleMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">    sampleMap[<span class="string">&quot;test&quot;</span>] = <span class="number">1</span></span><br><span class="line">    fmt.Println(sampleMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: assignment to entry in nil map</span><br></pre></td></tr></table></figure>

<p>必须使用make或者将map初始化之后，才可以添加元素。</p>
<p>以上代码可以改为:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sampleMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">    sampleMap = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="string">&quot;test1&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    sampleMap[<span class="string">&quot;test&quot;</span>] = <span class="number">1</span></span><br><span class="line">    fmt.Println(sampleMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以正确输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[test1:1 test:1]</span><br></pre></td></tr></table></figure>

<h1 id="amp-dilbert-Position和-amp-dilbert-Position是不同的"><a href="#amp-dilbert-Position和-amp-dilbert-Position是不同的" class="headerlink" title="&amp;dilbert.Position和(&amp;dilbert).Position是不同的"></a><code>&amp;dilbert.Position</code>和<code>(&amp;dilbert).Position</code>是不同的</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;dilbert.Position`相当于`&amp;(dilbert.Position)`而非`(&amp;dilbert).Position</span><br></pre></td></tr></table></figure>

<p>请看例子：</p>
<p>请问输出什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">        ID <span class="keyword">int</span></span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        Address <span class="keyword">string</span></span><br><span class="line">        DoB time.Time</span><br><span class="line">        Position <span class="keyword">string</span></span><br><span class="line">        Salary <span class="keyword">int</span></span><br><span class="line">        ManagerID <span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> dilbert Employee</span><br><span class="line"></span><br><span class="line">    dilbert.Position = <span class="string">&quot;123&quot;</span></span><br><span class="line"></span><br><span class="line">    position := &amp;dilbert.Position</span><br><span class="line">    fmt.Println(position)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xc42006c220</span><br></pre></td></tr></table></figure>

<p>输出的是内存地址</p>
<p>修改一下，把<code>&amp;dilbert.Position</code>改为<code>(&amp;dilbert).Position</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">        ID <span class="keyword">int</span></span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        Address <span class="keyword">string</span></span><br><span class="line">        DoB time.Time</span><br><span class="line">        Position <span class="keyword">string</span></span><br><span class="line">        Salary <span class="keyword">int</span></span><br><span class="line">        ManagerID <span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> dilbert Employee</span><br><span class="line"></span><br><span class="line">    dilbert.Position = <span class="string">&quot;123&quot;</span></span><br><span class="line"></span><br><span class="line">    position := (&amp;dilbert).Position</span><br><span class="line">    fmt.Println(position)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>

<h1 id="Go语言中函数返回的是值的时候，不能赋值"><a href="#Go语言中函数返回的是值的时候，不能赋值" class="headerlink" title="Go语言中函数返回的是值的时候，不能赋值"></a>Go语言中函数返回的是值的时候，不能赋值</h1><p>请看下面例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID <span class="keyword">int</span></span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Address <span class="keyword">string</span></span><br><span class="line">    DoB time.Time</span><br><span class="line">    Position <span class="keyword">string</span></span><br><span class="line">    Salary <span class="keyword">int</span></span><br><span class="line">    ManagerID <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EmployeeByID</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">Employee</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Employee&#123;ID:id&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    EmployeeByID(<span class="number">1</span>).Salary = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问能编译通过吗？</p>
<p>运行，输出报错：<code>cannot assign to EmployeeByID(1).Salary</code></p>
<p>在本例子中，函数<code>EmployeeById(id int)</code>返回的是值类型的，它的取值<code>EmployeeByID(1).Salary</code>也是一个值类型；值类型是什么概念？值类型就是和赋值语句<code>var a = 1</code>或<code>var a = hello world</code>等号<code>=</code>右边的<code>1</code>、<code>Hello world</code>是一个概念，他是不能够被赋值的，只有变量能够被赋值。</p>
<p>修改程序如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID <span class="keyword">int</span></span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Address <span class="keyword">string</span></span><br><span class="line">    DoB time.Time</span><br><span class="line">    Position <span class="keyword">string</span></span><br><span class="line">    Salary <span class="keyword">int</span></span><br><span class="line">    ManagerID <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EmployeeByID</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">Employee</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Employee&#123;ID:id&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = EmployeeByID(<span class="number">1</span>)</span><br><span class="line">    a.Salary = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就可以编译通过了</p>
<h1 id="在声明方法时，如果一个类型名称本身就是一个指针的话，不允许出现在方法的接收器中"><a href="#在声明方法时，如果一个类型名称本身就是一个指针的话，不允许出现在方法的接收器中" class="headerlink" title="在声明方法时，如果一个类型名称本身就是一个指针的话，不允许出现在方法的接收器中"></a>在声明方法时，如果一个类型名称本身就是一个指针的话，不允许出现在方法的接收器中</h1><p>请看下面的例子，请问会编译通过吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> littleGirl <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> girl *littleGirl</span><br><span class="line"></span><br><span class="line"><span class="comment">// girl是一个指针，不能作为方法接受</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this girl)</span> <span class="title">changeName</span><span class="params">(name <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">	this.Name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	littleGirl := girl&#123;Name:<span class="string">&quot;Rose&quot;</span>, Age:<span class="number">1</span>&#125;</span><br><span class="line">	</span><br><span class="line">	girl.changeName(<span class="string">&quot;yoyo&quot;</span>)</span><br><span class="line">	fmt.Println(littleGirl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>答案:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不能编译通过，会提示“invalid receiver type girl(girl is a pointer type)”</span><br></pre></td></tr></table></figure>

<p>Go语言中规定，<strong>只有类型（Type）和指向他们的指针（*Type）才是可能会出现在接收器声明里的两种接收器，</strong>为了避免歧义，明确规定，如果一个类型名本身就是一个指针的话，是不允许出现在接收器中的。</p>
<h1 id="函数允许nil指针作为参数，也允许用nil作为方法的接收器"><a href="#函数允许nil指针作为参数，也允许用nil作为方法的接收器" class="headerlink" title="函数允许nil指针作为参数，也允许用nil作为方法的接收器"></a>函数允许nil指针作为参数，也允许用nil作为方法的接收器</h1><p>请看下面的例子，请问能编译通过吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> littleGirl <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this littleGirl)</span> <span class="title">changeName</span><span class="params">(name <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">	fmt.Println(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	little := littleGirl&#123;Name:<span class="string">&quot;Rose&quot;</span>, Age:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">	little = <span class="literal">nil</span></span><br><span class="line">	little.changeName(<span class="string">&quot;yoyo&quot;</span>)</span><br><span class="line">	fmt.Println(little)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>答案:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不能编译通过，显示&quot;cannot use nil as type littleGirl in assignment&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Go语言中，允许方法用nil指针作为其接收器，也允许函数将nil指针作为参数</strong>。而上述代码中的<code>littleGirl</code>不是指针类型，改为<code>*littleGirl</code>，然后变量<code>little</code>赋值为<code>&amp;littleGirl&#123;Name:&quot;Rose&quot;, Age:1&#125;</code>就可以编译通过了。<br>并且，nil对于对象来说是合法的零值的时候，比如map或者slice，也可以编译通过并正常运行。</p>
<h1 id="Golang的时间格式化"><a href="#Golang的时间格式化" class="headerlink" title="Golang的时间格式化"></a>Golang的时间格式化</h1><p>不同于PHP的<code>date(&quot;Y-m-d H:i:s&quot;, time())</code>，Golang的格式化奇葩的很，不能使用诸如<code>Y-m-d H:i:s</code>的东西，而是使用<code>2006-01-02 15:04:05</code>这个时间的格式，请记住这个时间，据说这是Golang的诞生时间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">time := time.Now()</span><br><span class="line"></span><br><span class="line">time.Format(<span class="string">&quot;20060102&quot;</span>) <span class="comment">//相当于Ymd</span></span><br><span class="line"></span><br><span class="line">time.Format(<span class="string">&quot;2006-01-02&quot;</span>)<span class="comment">//相当于Y-m-d</span></span><br><span class="line"></span><br><span class="line">time.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)<span class="comment">//相当于Y-m-d H:i:s</span></span><br><span class="line"></span><br><span class="line">time.Format(<span class="string">&quot;2006-01-02 00:00:00&quot;</span>)<span class="comment">//相当于Y-m-d 00:00:00</span></span><br></pre></td></tr></table></figure>

<h1 id="不要对Go并发函数的执行时机做任何假设"><a href="#不要对Go并发函数的执行时机做任何假设" class="headerlink" title="不要对Go并发函数的执行时机做任何假设"></a>不要对Go并发函数的执行时机做任何假设</h1><p>请看下列的列子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	names := []<span class="keyword">string</span>&#123;<span class="string">&quot;lily&quot;</span>, <span class="string">&quot;yoyo&quot;</span>, <span class="string">&quot;cersei&quot;</span>, <span class="string">&quot;rose&quot;</span>, <span class="string">&quot;annei&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, name := <span class="keyword">range</span> names&#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">			fmt.Println(name)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">	runtime.Gosched()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问输出什么？</p>
<p>答案:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">annei</span><br><span class="line">annei</span><br><span class="line">annei</span><br><span class="line">annei</span><br><span class="line">annei</span><br></pre></td></tr></table></figure>

<p>为什么呢？是不是有点诧异？<br>输出的都是“annei”，而“annei”又是“names”的最后一个元素，那么也就是说程序打印出了最后一个元素的值，<strong>而name对于匿名函数来讲又是一个外部的值</strong>。因此，我们可以做一个推断：虽然每次循环都启用了一个协程，但是这些协程都是引用了外部的变量，当协程创建完毕，再执行打印动作的时候，name的值已经不知道变为啥了，因为主函数协程也在跑，大家并行，但是在此由于names数组长度太小，当协程创建完毕后，主函数循环早已结束，所以，打印出来的都是遍历的names最后的那一个元素“annei”。<br>如何证实以上的推断呢？<br>其实很简单，每次循环结束后，停顿一段时间，等待协程打印当前的name便可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	names := []<span class="keyword">string</span>&#123;<span class="string">&quot;lily&quot;</span>, <span class="string">&quot;yoyo&quot;</span>, <span class="string">&quot;cersei&quot;</span>, <span class="string">&quot;rose&quot;</span>, <span class="string">&quot;annei&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, name := <span class="keyword">range</span> names&#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">			fmt.Println(name)</span><br><span class="line">		&#125;()</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">	runtime.Gosched()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lily</span><br><span class="line">yoyo</span><br><span class="line">cersei</span><br><span class="line">rose</span><br><span class="line">annei</span><br></pre></td></tr></table></figure>

<p>以上我们得出一个结论，不要对“go函数”的执行时机做任何的假设，除非你确实能做出让这种假设成为绝对事实的保证。</p>
<h1 id="假设T类型的方法上接收器既有T类型的，又有-T指针类型的，那么就不可以在不能寻址的T值上调用-T接收器的方法"><a href="#假设T类型的方法上接收器既有T类型的，又有-T指针类型的，那么就不可以在不能寻址的T值上调用-T接收器的方法" class="headerlink" title="假设T类型的方法上接收器既有T类型的，又有*T指针类型的，那么就不可以在不能寻址的T值上调用*T接收器的方法"></a>假设T类型的方法上接收器既有<code>T</code>类型的，又有<code>*T</code>指针类型的，那么就不可以在不能寻址的T值上调用<code>*T</code>接收器的方法</h1><p>请看代码,试问能正常编译通过吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Lili <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Lili *Lili)</span> <span class="title">fmtPointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;poniter&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Lili Lili)</span> <span class="title">fmtReference</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;reference&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	li := Lili&#123;&#125;</span><br><span class="line">	li.fmtPointer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">能正常编译通过，并输出&quot;poniter&quot;</span><br></pre></td></tr></table></figure>

<p>感觉有点诧异，请接着看以下的代码，试问能编译通过？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Lili <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Lili *Lili)</span> <span class="title">fmtPointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;poniter&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Lili Lili)</span> <span class="title">fmtReference</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;reference&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Lili&#123;&#125;.fmtPointer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不能编译通过。</span><br><span class="line">“cannot call pointer method on Lili literal”</span><br><span class="line">“cannot take the address of Lili literal”</span><br></pre></td></tr></table></figure>

<p>是不是有点奇怪？这是为什么呢？<strong>其实在第一个代码示例中，main主函数中的“li”是一个变量，li的虽然是类型Lili，但是li是可以寻址的</strong>，&amp;li的类型是<code>*Lili</code>，因此可以调用*Lili的方法。</p>
<h1 id="一个包含nil指针的接口不是nil接口"><a href="#一个包含nil指针的接口不是nil接口" class="headerlink" title="一个包含nil指针的接口不是nil接口"></a>一个包含nil指针的接口不是nil接口</h1><p>请看下列代码，试问返回什么</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debug = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">	<span class="keyword">if</span> debug&#123;</span><br><span class="line">		buf = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	&#125;</span><br><span class="line">	f(buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;surprise!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是输出：surprise。<br>ok，让我们吧<code>debug</code>开关关掉，及<code>debug</code>的值变为<code>false</code>。那么输出什么呢？是不是什么都不输出？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debug = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">	<span class="keyword">if</span> debug&#123;</span><br><span class="line">		buf = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	&#125;</span><br><span class="line">	f(buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;surprise!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是：依然输出surprise。</p>
<p>这是为什么呢？<br>这就牵扯到一个概念了，是关于接口值的。<strong>概念上讲一个接口的值分为两部分：一部分是类型，一部分是类型对应的值，</strong>他们分别叫：<strong>动态类型和动态值。</strong>类型系统是针对编译型语言的，类型是编译期的概念，因此类型不是一个值。<br>在上述代码中，给f函数的out参数赋了一个<code>*bytes.Buffer</code>的空指针，所以out的动态值是nil。然而它的动态类型是*bytes.Buffer，意思是：“A non-nil interface containing a nil pointer”，所以“out!=nil”的结果依然是true。<br>但是，对于直接的<code>*bytes.Buffer</code>类型的判空不会出现此问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">	<span class="keyword">if</span> buf == <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;right&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是输出: right<br><strong>只有 接口指针 传入函数的接口参数时，才会出现以上的坑。</strong><br>修改起来也很方便，把<code>*bytes.Buffer</code>改为<code>io.Writer</code>就好了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> debug = <span class="literal">false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> buf  io.Writer <span class="comment">//原来是var buf *bytes.Buffer</span></span><br><span class="line">	<span class="keyword">if</span> debug&#123;</span><br><span class="line">		buf = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	&#125;</span><br><span class="line">	f(buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;surprise!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="将map转化为json字符串的时候，json字符串中的顺序和map赋值顺序无关"><a href="#将map转化为json字符串的时候，json字符串中的顺序和map赋值顺序无关" class="headerlink" title="将map转化为json字符串的时候，json字符串中的顺序和map赋值顺序无关"></a>将map转化为json字符串的时候，json字符串中的顺序和map赋值顺序无关</h1><p>请看下列代码，请问输出什么？若为json字符串，则json字符串中key的顺序是什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	params := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">	params[<span class="string">&quot;id&quot;</span>] = <span class="string">&quot;1&quot;</span></span><br><span class="line">	params[<span class="string">&quot;id1&quot;</span>] = <span class="string">&quot;3&quot;</span></span><br><span class="line">	params[<span class="string">&quot;controller&quot;</span>] = <span class="string">&quot;sections&quot;</span></span><br><span class="line"></span><br><span class="line">	data, _ := json.Marshal(params)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：输出<code>&#123;&quot;controller&quot;:&quot;sections&quot;,&quot;id&quot;:&quot;1&quot;,&quot;id1&quot;:&quot;3&quot;&#125;</code><br><strong>利用Golang自带的json转换包转换，会将map中key的顺序改为字母顺序，而不是map的赋值顺序。</strong>map这个结构哪怕利用<code>for range</code>遍历的时候,其中的key也是无序的，可以理解为map就是个无序的结构，和php中的array要区分开来</p>
<h1 id="Json反序列化数字到interface-类型的值中，默认解析为float64类型"><a href="#Json反序列化数字到interface-类型的值中，默认解析为float64类型" class="headerlink" title="Json反序列化数字到interface{}类型的值中，默认解析为float64类型"></a>Json反序列化数字到interface{}类型的值中，默认解析为float64类型</h1><p>请看以下程序，程序想要输出json数据中整型<code>id</code>加上<code>3</code>的值,请问程序会报错吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	jsonStr := <span class="string">`&#123;&quot;id&quot;:1058,&quot;name&quot;:&quot;RyuGou&quot;&#125;`</span></span><br><span class="line">	<span class="keyword">var</span> jsonData <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), &amp;jsonData)</span><br><span class="line"></span><br><span class="line">	sum :=  jsonData[<span class="string">&quot;id&quot;</span>].(<span class="keyword">int</span>) + <span class="number">3</span></span><br><span class="line">	fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">答案是会报错，输出结果为：</span></span><br></pre></td></tr></table></figure>

<p>panic: interface conversion: interface {} is float64, not int</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 Golang 解析 JSON  格式数据时，若以 interface&#123;&#125; 接收数据，则会按照下列规则进行解析：</span><br></pre></td></tr></table></figure>

<p>bool, for JSON booleans</p>
<p>float64, for JSON numbers</p>
<p>string, for JSON strings</p>
<p>[]interface{}, for JSON arrays</p>
<p>map[string]interface{}, for JSON objects</p>
<p>nil for JSON null</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">应该改为：</span><br><span class="line">​<span class="string">``</span><span class="string">`go</span></span><br><span class="line"><span class="string">func main()&#123;</span></span><br><span class="line"><span class="string">	jsonStr := `</span>&#123;<span class="string">&quot;id&quot;</span>:<span class="number">1058</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;RyuGou&quot;</span>&#125;<span class="string">`</span></span><br><span class="line"><span class="string">	var jsonData map[string]interface&#123;&#125;</span></span><br><span class="line"><span class="string">	json.Unmarshal([]byte(jsonStr), &amp;jsonData)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	sum :=  int(jsonData[&quot;id&quot;].(float64)) + 3</span></span><br><span class="line"><span class="string">	fmt.Println(sum)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="即使在有多个变量、且有的变量存在有的变量不存在、且这些变量共同赋值的情况下，也不可以使用-来给全局变量赋值"><a href="#即使在有多个变量、且有的变量存在有的变量不存在、且这些变量共同赋值的情况下，也不可以使用-来给全局变量赋值" class="headerlink" title="即使在有多个变量、且有的变量存在有的变量不存在、且这些变量共同赋值的情况下，也不可以使用:=来给全局变量赋值"></a>即使在有多个变量、且有的变量存在有的变量不存在、且这些变量共同赋值的情况下，也不可以使用<code>:=</code>来给全局变量赋值</h1><p><code>:=</code>往往是用来声明局部变量的，在多个变量赋值且有的值存在的情况下，<code>:=</code>也可以用来赋值使用,例如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msgStr := <span class="string">&quot;hello wolrd&quot;</span></span><br><span class="line">msgStr, err := <span class="string">&quot;hello&quot;</span>, errors.New(<span class="string">&quot;xxx&quot;</span>)<span class="comment">//err并不存在</span></span><br></pre></td></tr></table></figure>

<p>但是，假如全局变量也使用类似的方式赋值，就会出现问题，请看下列代码，试问能编译通过吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> varTest <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	varTest, err := function()</span><br><span class="line">	fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">()</span><span class="params">(<span class="keyword">string</span>, error)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>, errors.New(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是：通不过。输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">varTest declared and not used</span><br></pre></td></tr></table></figure>

<p>但是如果改成如下代码，就可以通过：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> varTest <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	err := errors.New(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">	varTest, err = function()</span><br><span class="line">	fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">()</span><span class="params">(<span class="keyword">string</span>, error)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>, errors.New(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error</span><br></pre></td></tr></table></figure>

<p>这是什么原因呢？<br>答案其实很简单，在<code>test</code>方法中，如果使用<code>varTest, err := function()</code>这种方式的话，相当于在函数中又定义了一个和全局变量<code>varTest</code>名字相同的局部变量，而这个局部变量又没有使用，所以会编译不通过。</p>
<h1 id="interface-是一个指向interface的指针类型，而不是interface类型"><a href="#interface-是一个指向interface的指针类型，而不是interface类型" class="headerlink" title="*interface 是一个指向interface的指针类型，而不是interface类型"></a>*interface 是一个指向interface的指针类型，而不是interface类型</h1><p>请问以下代码，能编译通过吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Father <span class="keyword">interface</span> &#123;</span><br><span class="line">	Hello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Child)</span><span class="title">Hello</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> buf  Child</span><br><span class="line">	buf = Child&#123;&#125;</span><br><span class="line">	f(&amp;buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out *Father)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;surprise!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是：不能编译通过。输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*Father is pointer to interface, not interface</span><br></pre></td></tr></table></figure>

<p>注意了：接口类型的变量可以被赋值为实现接口的结构体的实例，但是并不能代表接口的指针可以被赋值为实现接口的结构体的指针实例。即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var buf Father = Child&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>是对的，但是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var buf *Father = new(Child)</span><br></pre></td></tr></table></figure>

<p>却是不对的。应该改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var buf Father = Child&#123;&#125;</span><br><span class="line">var pointer *Father = &amp;buf</span><br></pre></td></tr></table></figure>

<p>要想让问题最开始的代码编译通过要将以上代码修改为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Father <span class="keyword">interface</span> &#123;</span><br><span class="line">	Hello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Child)</span><span class="title">Hello</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> buf  Father</span><br><span class="line">	buf = Child&#123;&#125;</span><br><span class="line">	f(&amp;buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out *Father)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;surprise!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/21/blog/nginx-location/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/21/blog/nginx-location/" class="post-title-link" itemprop="url">nginx_location</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-21 17:19:54" itemprop="dateCreated datePublished" datetime="2022-01-21T17:19:54+08:00">2022-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-24 10:35:43" itemprop="dateModified" datetime="2022-01-24T10:35:43+08:00">2022-01-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>nginx官方文档给出location语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> [=|~|~*|^~] uri &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>其中，方括号中的四种标识符是可选项，用来改变请求字符串和uri的匹配方式。uri是待匹配的请求字符串，可以是不包含正则的字符串，这种模式被称为“标准的uri”；也可以包含正则，这种模式被称为”正则uri”，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(php|php5)?$</span> &#123;``&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二、四种可选的标识符"><a href="#二、四种可选的标识符" class="headerlink" title="二、四种可选的标识符"></a>二、四种可选的标识符</h4><table>
<thead>
<tr>
<th><strong>标识符</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td><strong>精确匹配</strong>；用于标准uri前，要求请求字符串和uri严格匹配。如果匹配成功，就停止匹配，立即执行该location里面的请求。</td>
</tr>
<tr>
<td>~</td>
<td><strong>正则匹配</strong>；用于正则uri前，表示uri里面包含正则，并且区分大小写。</td>
</tr>
<tr>
<td>~*</td>
<td><strong>正则匹配</strong>；用于正则uri前，表示uri里面包含正则，不区分大小写。</td>
</tr>
<tr>
<td>^~</td>
<td><strong>非正则匹配</strong>；用于标准uri前，nginx服务器匹配到前缀最多的uri后就结束，该模式匹配成功后，不会使用正则匹配。</td>
</tr>
<tr>
<td>无</td>
<td><strong>普通匹配（最长字符匹配）</strong>；与location顺序无关，是按照匹配的长短来取匹配结果。若完全匹配，就停止匹配。</td>
</tr>
</tbody></table>
<p><strong>备注</strong>：</p>
<p>1、如果uri里面包含正则表达式，就必须使用<del>或</del>*标识符；</p>
<p>2、针对<del>和</del>*匹配标识符，可以在前面加上!来取反，如下：</p>
<p>!~ 表示正则不匹配，区分大小写。</p>
<p>!~* 表示正则不匹配，不区分大小写。</p>
<p><strong>2.1 “=”精准匹配案例</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span>  = /login &#123;</span><br><span class="line">  <span class="comment"># 精确匹配 /login ，匹配成功后，立即结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.2 “~”区分大小写正则匹配案例</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ /images/</span> &#123;</span><br><span class="line">  <span class="comment">#正则匹配，区分大小写，匹配成功后，立即结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.3 “~*”不区分大小写正则匹配案例</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* /images/</span> &#123;</span><br><span class="line">  <span class="comment">#正则匹配，不区分大小写，匹配成功后，立即结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.4 “^~” 不进行正则匹配的标准匹配</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /images/ &#123;</span><br><span class="line">  <span class="comment"># 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2.5 普通匹配（最长字符匹配）</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span>  /blog/ &#123;</span><br><span class="line">  <span class="comment"># 与location顺序无关</span></span><br><span class="line">  <span class="comment"># 若完全匹配成功，就不在继续匹配，否则还会进行正则匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、location匹配顺序"><a href="#三、location匹配顺序" class="headerlink" title="三、location匹配顺序"></a>三、location匹配顺序</h4><p>在没有标识符的请求下，匹配规则如下：</p>
<p>1、nginx服务器首先在server块的多个location块中搜索是否有标准的uri和请求字符串匹配。如果有多个标准uri可以匹配，就匹配其中匹配度最高的一个location。</p>
<p>2、然后，nginx在使用location块中，正则uri和请求字符串，进行匹配。如果正则匹配成功，则结束匹配，并使用这个location处理请求；如果正则匹配失败，则使用标准uri中，匹配度最高的location。</p>
<p><strong>备注：</strong></p>
<p>1、如果有精确匹配，会先进行精确匹配，匹配成功，立刻返回结果。</p>
<p>2、<strong>普通匹配与顺序无关，因为按照匹配的长短来取</strong>匹配结果。</p>
<p>3、<em><strong>正则匹配与顺序有关</strong></em>，因为是从上往下匹配。(首先匹配，就结束解析过程)</p>
<p>4、在location中，有一种统配的location，所有的请求，都可以匹配，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span>  / &#123;</span><br><span class="line">  <span class="comment"># 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求</span></span><br><span class="line">  <span class="comment"># 但是正则和最长字符串会优先匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>结合标识符，匹配顺序如下：</strong></em></p>
<p><strong><em>(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location <del>,</del></em> 正则顺序) &gt; (location 部分起始路径) &gt; (location /)</strong>*</p>
<p><em><strong>即</strong></em></p>
<p><strong>（精确匹配）&gt; (最长字符串匹配，但完全匹配) &gt;（非正则匹配）&gt;（正则匹配）&gt;（最长字符串匹配，不完全匹配）&gt;（location通配）</strong></p>
<h4 id="五、案例"><a href="#五、案例" class="headerlink" title="五、案例"></a>五、案例</h4><p>假设，现有如下一些规则：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> = / &#123;  </span><br><span class="line">   //精确匹配/ ，主机名后面不能带任何字符串</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">&quot;规则A&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="attribute">location</span> = /login &#123;</span><br><span class="line">  //精确匹配 /<span class="attribute">login</span> 开头的地址，匹配符合以后，不在继续往下搜索 </span><br><span class="line">    echo <span class="string">&quot;规则B&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /blog/ &#123; </span><br><span class="line">  //非正则匹配，匹配/blog/后，停止往下搜索正则，采用这一条</span><br><span class="line">  <span class="attribute">echo</span> <span class="string">&quot;规则C&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~  \.(gif|jpg|png|js|css)$</span> &#123;</span><br><span class="line">    //区分大小写的正则匹配  若匹配成功，停止往下搜索正则，采用这一条</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">&quot;规则D&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~* \.png$</span> &#123;  </span><br><span class="line">   //区分大小写的正则匹配 ，停止往下搜索正则，采用这一条</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">&quot;规则E&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">  //因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求</span><br><span class="line">  //如果没任何规则匹配上，就采用这条规则</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">&quot;规则F&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="attribute">location</span> /blog/detail &#123; </span><br><span class="line">  //最长字符串匹配，若完全匹配成功，就不在继续匹配，否则还会进行正则匹配</span><br><span class="line">  <span class="attribute">echo</span> <span class="string">&quot;规则G&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="attribute">location</span> /images &#123;  </span><br><span class="line">    //最长字符串匹配，同上 </span><br><span class="line">    <span class="attribute">echo</span> <span class="string">&quot;规则Y&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /static/files &#123;  </span><br><span class="line">    //非正则匹配，若匹配成功，就不在继续匹配</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">&quot;规则X&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、当访问根路径/的时候，比如<a target="_blank" rel="noopener" href="http://www.findme.wang/">http://www.findme.wang/</a> ，会匹配规则A。</p>
<p>2、当访如<a target="_blank" rel="noopener" href="http://www.findme.wang/login">http://www.findme.wang/login</a> ，会匹配规则B。</p>
<p>3、当访如<a target="_blank" rel="noopener" href="http://www.findme.wang/login.html">http://www.findme.wang/login.html</a> ，会匹配规则F。</p>
<p>4、当访如<a target="_blank" rel="noopener" href="http://www.findme.wang/blog/d/3.html">http://www.findme.wang/blog/d/3.html</a> ，会匹配规则C。分析思路，首先看看，“<strong>精确匹配</strong>”是否可以匹配成功，显示不可以；然后，看看是否可以“<strong>普通匹配</strong>”是否可以完全匹配，显示也没有；接着在看看非正则匹配，是否可以匹配成功，发现同规则C匹配上了，所以采用了规则C。</p>
<p>5、当访如<a target="_blank" rel="noopener" href="http://www.findme.wang/blog/detail/3.html">http://www.findme.wang/blog/detail/3.html</a> ，会匹配规则G。分析思路，首先看看，“<strong>精确匹配</strong>”是否可以匹配成功，显示不可以；然后，看看是否可以“<strong>普通匹配</strong>”是否可以完全匹配，显示可以，采用G。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/21/blog/nginx-lua/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/21/blog/nginx-lua/" class="post-title-link" itemprop="url">nginx_lua 阶段</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-21 16:08:42" itemprop="dateCreated datePublished" datetime="2022-01-21T16:08:42+08:00">2022-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-24 10:35:43" itemprop="dateModified" datetime="2022-01-24T10:35:43+08:00">2022-01-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对刚接触Ngx_lua的读者来说，可能会存在下面两个困惑。</p>
<p>1、Lua在Nginx的哪些阶段可以执行代码？<br>2、Lua在Nginx的每个阶段可以执行哪些操作？</p>
<p>只有理解了这两个问题，才能在业务中巧妙地利用Ngx_Lua来完成各项需求。</p>
<p>Nginx的11个执行阶段，每个阶段都有自己能够执行的指令，并可以实现不同的功能。Ngx_Lua的功能大部分是基于Nginx这11个执行阶段开发和配置的，Lua代码在这些指令块中执行，并依赖于它们的执行顺序。本章将对Ngx_Lua的执行阶段进行一一讲解。</p>
<p>Nginx和Lua最基本的构建块脚本是指令集。指令集用于确定什么时候用户的Lua代码运行和结果将会被怎么使用。下面的图显示指令集的执行顺序。</p>
<p><img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/2699372-010f4989264186a1.png" alt="img"></p>
<p>Lua Nginx 模块指令集</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">所处处理阶段</th>
<th align="left">使用范围</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">init_by_lua init_by_lua_file</td>
<td align="left">loading-config</td>
<td align="left">http</td>
<td align="left">nginx Master<strong>进程加载配置</strong>时执行； 通常用于初始化全局配置/预加载Lua模块</td>
</tr>
<tr>
<td align="left">init_worker_by_lua init_worker_by_lua_file</td>
<td align="left">starting-worker</td>
<td align="left">http</td>
<td align="left">每个Nginx Worker<strong>进程启动时调用的计时器</strong>，如果Master进程不允许则只会在init_by_lua之后调用； 通常用于定时拉取配置/数据，或者后端服务的健康检查</td>
</tr>
<tr>
<td align="left">set_by_lua set_by_lua_file</td>
<td align="left">rewrite</td>
<td align="left">server,server if,location,location if</td>
<td align="left"><strong>设置nginx变量</strong>，可以实现复杂的赋值逻辑；<strong>此处是阻塞的</strong>，Lua代码要做到非常快；</td>
</tr>
<tr>
<td align="left">rewrite_by_lua rewrite_by_lua_file</td>
<td align="left">rewrite tail</td>
<td align="left">http,server,location,location if</td>
<td align="left">rewrite阶段处理，可以实现<strong>复杂的转发/重定向逻辑</strong>；</td>
</tr>
<tr>
<td align="left">access_by_lua access_by_lua_file</td>
<td align="left">access tail</td>
<td align="left">http,server,location,location if</td>
<td align="left">请求访问阶段处理，用于<strong>访问控制</strong></td>
</tr>
<tr>
<td align="left">content_by_lua content_by_lua_file</td>
<td align="left">content</td>
<td align="left">location，location if</td>
<td align="left">内容处理器，<strong>接收请求处理</strong>并输出响应</td>
</tr>
<tr>
<td align="left">header_filter_by_lua header_filter_by_lua_file</td>
<td align="left">output-header-filter</td>
<td align="left">http，server，location，location if</td>
<td align="left">设置header和cookie</td>
</tr>
<tr>
<td align="left">body_filter_by_lua body_filter_by_lua_file</td>
<td align="left">output-body-filter</td>
<td align="left">http，server，location，location if</td>
<td align="left">对响应数据进行过滤，比如截断、替换。</td>
</tr>
<tr>
<td align="left">log_by_lua log_by_lua_file</td>
<td align="left">log</td>
<td align="left">http，server，location，location if</td>
<td align="left">log阶段处理，比如记录访问量/统计平均响应时间</td>
</tr>
</tbody></table>
<p>更详细的解释请参考<a target="_blank" rel="noopener" href="http://wiki.nginx.org/HttpLuaModule#Directives%E3%80%82%E5%A6%82%E4%B8%8A%E6%8C%87%E4%BB%A4%E5%BE%88%E5%A4%9A%E5%B9%B6%E4%B8%8D%E5%B8%B8%E7%94%A8%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%88%91%E4%BB%AC%E5%8F%AA%E6%8B%BF%E5%85%B6%E4%B8%AD%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%E5%81%9A%E6%BC%94%E7%A4%BA%E3%80%82">http://wiki.nginx.org/HttpLuaModule#Directives。如上指令很多并不常用，因此我们只拿其中的一部分做演示。</a></p>
<h2 id="init-by-lua"><a href="#init-by-lua" class="headerlink" title="init_by_lua"></a>init_by_lua</h2><p>每次Nginx重新加载配置时执行，可以用它来完成一些耗时模块的加载，或者初始化一些全局配置；在Master进程创建Worker进程时，此指令中加载的全局变量会进行Copy-OnWrite，即会复制到所有全局变量到Worker进程。</p>
<h4 id="1-nginx-conf配置文件中的http部分添加如下代码"><a href="#1-nginx-conf配置文件中的http部分添加如下代码" class="headerlink" title="1. nginx.conf配置文件中的http部分添加如下代码"></a>1. nginx.conf配置文件中的http部分添加如下代码</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#共享全局变量，在所有worker间共享</span></span><br><span class="line"><span class="attribute">lua_shared_dict</span> shared_data <span class="number">1m</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">init_by_lua_file</span> /usr/example/lua/init.lua;</span><br></pre></td></tr></table></figure>

<h4 id="2-init-lua"><a href="#2-init-lua" class="headerlink" title="2. init.lua"></a>2. init.lua</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 初始化耗时的模块</span><br><span class="line"><span class="attribute">local</span> redis = require(<span class="string">&quot;resty.redis&quot;</span>)</span><br><span class="line">local cjson = require(<span class="string">&quot;cjson&quot;</span>)</span><br><span class="line"></span><br><span class="line">-- 全局变量，不推荐</span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">-- 共享全局内存</span><br><span class="line">local shared_data = ngx.shared.shared_data</span><br><span class="line">shared_data:set(<span class="string">&quot;count&quot;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="一、-init-by-lua-block"><a href="#一、-init-by-lua-block" class="headerlink" title="一、 init_by_lua_block"></a>一、 init_by_lua_block</h3><p>init_by_lua_block是init_by_lua的替代版本，在OpenResty 1.9.3.1或Lua-Nginx-Modulev 0.9.17之前使用的都是init_by_lua。init_by_lua_block比init_by_lua更灵活，所以建议优先选用init_by_lua_block。<br>本章中的执行阶段都采用*_block格式的指令，后续不再说明。</p>
<h4 id="1-1-阶段说明"><a href="#1-1-阶段说明" class="headerlink" title="1.1　阶段说明"></a>1.1　阶段说明</h4><p>语法：init_by_lua_block {lua-script-str}<br>配置环境：http<br>阶段：loading-config<br>含义：当Nginx的master进程加载Nginx配置文件（加载或重启Nginx进程）时，会在全局的Lua VM（Virtual Machine，虚拟机）层上运行<lua-script-str> 指定的代码，每次当Nginx获得HUP（即Hangup）重载信号加载进程时，代码都会被重新执行。</p>
<h4 id="1-2-初始化配置"><a href="#1-2-初始化配置" class="headerlink" title="1.2 初始化配置"></a>1.2 初始化配置</h4><p>在loading-config阶段一般会执行如下操作。<br>1．初始化Lua全局变量，特别适合用来处理在启动master进程时就要求存在的数据，对CPU消耗较多的功能也可以在此处处理。<br>2．预加载模块。<br>3．初始化lua_shared_dict共享内存的数据（关于共享内存详见第10章）。<br>示例如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span>  webuser webuser;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">10240</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">10240</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="attribute">log_format</span> main <span class="string">&#x27;$remote_addr-$remote_user[$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span> </span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &quot;$request_time&quot; &quot;$upstream_addr $upstream_status $upstream_response_time&quot;  &quot;upstream_time_sum:$upstream_time_sum&quot;  &quot;jk_uri:$jk_uri&quot;&#x27;</span>;</span><br><span class="line">    <span class="attribute">access_log</span>  logs/access.log  main;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="attribute">lua_package_path</span> <span class="string">&quot;/usr/local/nginx_1.12.2/conf/lua_modules/?.lua;;&quot;</span>;</span><br><span class="line">    <span class="attribute">lua_package_cpath</span> <span class="string">&quot;/usr/local/nginx_1.12.2/conf/lua_modules/c_package/?.so;;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">lua_shared_dict</span> dict_a <span class="number">100k</span>;  --声明一个Lua共享内存，dict_a为100<span class="attribute">KB</span></span><br><span class="line">    init_by_lua_block &#123;</span><br><span class="line">-- cjson.so文件需要手动存放在lua_package_cpath搜索路径下，如果是OpenResty，就不必了，因为它默认支持该操作</span><br><span class="line">          <span class="attribute">cjson</span> = require <span class="string">&quot;cjson&quot;</span>; </span><br><span class="line">          <span class="attribute">local</span> dict_a = ngx.shared.dict_a;</span><br><span class="line">          dict_a:set(&quot;abc&quot;, 9)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  testnginx.com;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">           <span class="section">content_by_lua_block</span> &#123;</span><br><span class="line">               ngx.say(cjson.encode(&#123;<span class="attribute">a</span> = <span class="number">1</span>, b = <span class="number">2</span>&#125;))</span><br><span class="line">               local dict_a = ngx.shared.dict_a;</span><br><span class="line">               ngx.say(&quot;abc=&quot;,dict_a:get(&quot;abc&quot;))</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p>curl -I <a target="_blank" rel="noopener" href="http://testnginx.com/">http://testnginx.com/</a><br>{“a”:1,”b”:2}<br>abc=9</p>
<h4 id="1-3-控制初始值"><a href="#1-3-控制初始值" class="headerlink" title="1.3　控制初始值"></a>1.3　控制初始值</h4><p>在init_by_lua_block阶段设置的初始值，即使在其他执行阶段被修改过，当Nginx重载配置时，这些值就又会恢复到初始状态。如果在重载Nginx配置时不希望再次改动这些初始值，可以在代码中做如下调整。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">init_by_lua_block</span> &#123;</span><br><span class="line">      <span class="attribute">local</span> cjson = require <span class="string">&quot;cjson&quot;</span>;</span><br><span class="line">      <span class="attribute">local</span> dict_a = ngx.shared.dict_a;</span><br><span class="line">      <span class="attribute">local</span> v = dict_a:get(<span class="string">&quot;abc&quot;</span>);  --判断初始值是否已经被<span class="attribute">set</span></span><br><span class="line">      if not v then                 --如果没有，就执行初始化操作</span><br><span class="line">        dict_a:set(<span class="string">&quot;abc&quot;</span>, <span class="number">9</span>)</span><br><span class="line">      end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-init-by-lua-file"><a href="#1-4-init-by-lua-file" class="headerlink" title="1.4　init_by_lua_file"></a>1.4　init_by_lua_file</h4><p>init_by_lua_file和init_by_lua_block的作用一样，主要用于将init_by_lua_block的内容转存到指定的文件中，这样Lua代码就不必全部写在Nginx配置里了，易读性更强。<br>init_by_lua_file支持配置绝对路径和相对路径。<strong>相对路径是在启动Nginx时由-p PATH 决定的</strong>，如果启动Nginx时没有配置-p PATH，就会使用编译时–prefix的值，该值一般存放在Nginx的prefix（也可以用prefix（也可以用{prefix}来表示）变量中。init_by_lua_file和Nginx的include指令的相对路径一致。<br>举例如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">init_by_lua_file</span> conf/lua/init.lua;  --相对路径</span><br><span class="line"><span class="attribute">init_by_lua_file</span> /usr/local/nginx/conf/lua/init.lua; --绝对路径</span><br><span class="line">init.lua文件的内容如下：</span><br><span class="line"><span class="attribute">cjson</span> = require <span class="string">&quot;cjson&quot;</span></span><br><span class="line">local dict_a = ngx.shared.dict_a</span><br><span class="line">local v = dict_a:get(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">if not v then</span><br><span class="line">   dict_a:set(<span class="string">&quot;abc&quot;</span>, <span class="number">9</span>)</span><br><span class="line">end  </span><br></pre></td></tr></table></figure>
<p>1.5　可使用的Lua API指令<br>init_by_lua是Nginx配置加载的阶段，很多Nginx API for Lua命令是不支持的。目前已知支持的Nginx API for Lua的命令有ngx.log、ngx.shared.DICT、print。<br>注意：init_by_lua中的表示通配符，init_by_lua即所有以init_by_lua开头的API。后续的通配符亦是如此，不再另行说明。</p>
<p>二、init_worker_by_lua_block<br>2.1　阶段说明<br><strong>语法：</strong>init_worker_by_lua_block {lua-script-str}<br><strong>配置环境：</strong>http<br><strong>阶段：</strong>starting-worker<br><strong>含义：</strong>当master进程被启动后，每个worker进程都会执行Lua代码。如果Nginx禁用了master进程，init_by_lua*将会直接运行。</p>
<p>2.2　启动Nginx的定时任务<br>在init_worker_by_lua_block执行阶段最常见的功能是执行定时任务。示例如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span>  webuser webuser;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">3</span>;</span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">10240</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">10240</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">upstream</span>  test_12 &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:81</span>  weight=<span class="number">20</span>  max_fails=<span class="number">300000</span> fail_timeout=<span class="number">5s</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:82</span>  weight=<span class="number">20</span>  max_fails=<span class="number">300000</span> fail_timeout=<span class="number">5s</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">lua_package_path</span> <span class="string">&quot;<span class="variable">$&#123;prefix&#125;</span>conf/lua_modules/?.lua;;&quot;</span>;</span><br><span class="line">    <span class="attribute">lua_package_cpath</span> <span class="string">&quot;<span class="variable">$&#123;prefix&#125;</span>conf/lua_modules/c_package/?.so;;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="section">init_worker_by_lua_block</span>  &#123;</span><br><span class="line">        <span class="attribute">local</span> delay = <span class="number">3</span>  --<span class="number">3</span>秒</span><br><span class="line">        local cron_a   </span><br><span class="line">    --定时任务的函数</span><br><span class="line">        cron_a = function (premature)   </span><br><span class="line">            if not  premature then  --如果执行函数时没有传参，则该任务会一直被触发执行</span><br><span class="line">                ngx.log(ngx.ERR, <span class="string">&quot;Just do it !&quot;</span>)</span><br><span class="line">            end</span><br><span class="line">    </span><br><span class="line">        end</span><br><span class="line">    --每隔delay参数值的时间，就执行一次cron_a函数</span><br><span class="line">        local ok, err = ngx.timer.every(delay, cron_a)   </span><br><span class="line">        if not ok then</span><br><span class="line">            ngx.log(ngx.ERR, <span class="string">&quot;failed to create the timer: &quot;</span>, err)</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.3　动态进行后端健康检查<br>在init_worker_by_lua_block阶段，也可以实现后端健康检查的功能，用于检查后端HTTP服务是否正常，类似于Nginx商业版中的health_check功能。<br>如果使用OpenResty 1.9.3.2及以上的版本，默认已支持此模块；如果使用Nginx，则首先需要安装此模块<br>实现动态进行后端健康检查的功能，配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span>  webuser webuser;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">3</span>;</span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">10240</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">10240</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">upstream</span>  test_12 &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:81</span>  weight=<span class="number">20</span>  max_fails=<span class="number">10</span> fail_timeout=<span class="number">5s</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:82</span>  weight=<span class="number">20</span>  max_fails=<span class="number">10</span> fail_timeout=<span class="number">5s</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8231</span>  weight=<span class="number">20</span>  max_fails=<span class="number">10</span> fail_timeout=<span class="number">5s</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">lua_shared_dict</span> healthcheck <span class="number">1m</span>;  <span class="comment"># 存放upstream servers的共享内存，后端服务器组越多，配置就越大</span></span><br><span class="line">    <span class="attribute">lua_socket_log_errors</span> <span class="literal">off</span>;  <span class="comment"># 当TCP发送失败时，会发送error日志到error.log中，该过程会增加性能开销，建议关闭，以避免在健康检查过程中出现多台服务器宕机的情况，异常情况请使用ngx.log来记录</span></span><br><span class="line">    <span class="attribute">lua_package_path</span> <span class="string">&quot;<span class="variable">$&#123;prefix&#125;</span>conf/lua_modules/?.lua;;&quot;</span>;</span><br><span class="line">    <span class="attribute">lua_package_cpath</span> <span class="string">&quot;<span class="variable">$&#123;prefix&#125;</span>conf/lua_modules/c_package/?.so;;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="section">init_worker_by_lua_block</span>  &#123;</span><br><span class="line">        <span class="attribute">local</span> hc = require <span class="string">&quot;resty.upstream.healthcheck&quot;</span></span><br><span class="line">        local ok, err = hc.spawn_checker&#123;</span><br><span class="line">            <span class="attribute">shm</span> = <span class="string">&quot;healthcheck&quot;</span>,  -- 使用共享内存 </span><br><span class="line">            upstream = <span class="string">&quot;test_12&quot;</span>, -- 进行健康检查的upstream名字</span><br><span class="line">            type = <span class="string">&quot;http&quot;</span>,        -- 检查类型是http</span><br><span class="line">            http_req = <span class="string">&quot;GET /status HTTP/1.0\r\nHost: testnginx.com\r\n\r\n&quot;</span>,</span><br><span class="line">                    -- 用来发送HTTP请求的格式和数据，核实服务是否正常 </span><br><span class="line">            interval = <span class="number">3000</span>,  -- 设置检查的频率为每<span class="number">3s</span>一次</span><br><span class="line">            timeout = <span class="number">1000</span>,   -- 设置请求的超时时间为<span class="number">1s</span></span><br><span class="line">            fall = <span class="number">3</span>,  --设置连续失败<span class="number">3</span>次后就把后端服务改为down </span><br><span class="line">            rise = <span class="number">2</span>,  --设置连续成功<span class="number">2</span>次后就把后端服务改为up </span><br><span class="line">        valid_statuses = &#123;200, 302&#125;,  --设置请求成功的响应状态码是200和302</span><br><span class="line">            <span class="attribute">concurrency</span> = <span class="number">10</span>,  --设置发送请求的并发等级</span><br><span class="line">        &#125;</span><br><span class="line">        if not ok then</span><br><span class="line">            ngx.log(ngx.ERR, <span class="string">&quot;failed to spawn health checker: &quot;</span>, err)</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  testnginx.com;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">           <span class="attribute">proxy_pass</span> http://test_12;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># /status 定义了后端健康检查结果的输出页面</span></span><br><span class="line">        <span class="attribute">location</span> = /status &#123;</span><br><span class="line">            <span class="attribute">default_type</span> text/plain;</span><br><span class="line">            <span class="section">content_by_lua_block</span> &#123;</span><br><span class="line">                <span class="attribute">local</span> hc = require <span class="string">&quot;resty.upstream.healthcheck&quot;</span></span><br><span class="line">                --输出当前检查结果是哪个worker进程的</span><br><span class="line">                ngx.say(<span class="string">&quot;Nginx Worker PID: &quot;</span>, ngx.worker.pid())</span><br><span class="line">--status_page()输出后端服务器的详细情况</span><br><span class="line">                ngx.print(hc.status_page())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问<a target="_blank" rel="noopener" href="http://testnginx.com/status%E6%9F%A5%E7%9C%8B%E6%A3%80%E6%9F%A5%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%8C%E5%9B%BE8-1%E6%89%80%E7%A4%BA%E4%B8%BA%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%E3%80%82">http://testnginx.com/status查看检查的结果，图8-1所示为健康检查数据结果。</a></p>
<p>图8-1　健康检查数据结果<br>如果要检查多个upstream，则配置如下（只有黑色加粗位置的配置有变化）：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">local</span> ok, err = hc.spawn_checker&#123;</span><br><span class="line">    <span class="attribute">shm</span> = <span class="string">&quot;healthcheck&quot;</span>,</span><br><span class="line">    upstream = <span class="string">&quot;test_12&quot;</span>,</span><br><span class="line">    type = <span class="string">&quot;http&quot;</span>,</span><br><span class="line"></span><br><span class="line">    http_req = <span class="string">&quot;GET /status HTTP/1.0\r\nHost: testnginx.com\r\n\r\n&quot;</span>,</span><br><span class="line">    </span><br><span class="line">    interval = <span class="number">3000</span>,</span><br><span class="line">    timeout = <span class="number">1000</span>,</span><br><span class="line">    fall = <span class="number">3</span>,</span><br><span class="line">    rise = <span class="number">2</span>,</span><br><span class="line">    valid_statuses = &#123;200, 302&#125;,  </span><br><span class="line">    <span class="attribute">concurrency</span> = <span class="number">10</span>, </span><br><span class="line">&#125;</span><br><span class="line">local ok, err = hc.spawn_checker&#123;</span><br><span class="line">    <span class="attribute">shm</span> = <span class="string">&quot;healthcheck&quot;</span>,</span><br><span class="line">    upstream = <span class="string">&quot;test_34&quot;</span>,</span><br><span class="line">    type = <span class="string">&quot;http&quot;</span>,</span><br><span class="line"></span><br><span class="line">    http_req = <span class="string">&quot;GET /test HTTP/1.0\r\nHost: testnginx.com\r\n\r\n&quot;</span>,</span><br><span class="line">    interval = <span class="number">3000</span>,</span><br><span class="line">    timeout = <span class="number">1000</span>,</span><br><span class="line">    fall = <span class="number">3</span>,</span><br><span class="line">    rise = <span class="number">2</span>,</span><br><span class="line">    valid_statuses = &#123;200, 302&#125;, </span><br><span class="line">    <span class="attribute">concurrency</span> = <span class="number">10</span>,  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果把lua_socket_log_errors设置为on，那么当有异常出现时，例如出现了超时，就会往error.log里写日志，日志记录如图8-2所示。</p>
<p>图8-2　日志记录<br>经过lua-resty-upstream-healthcheck的健康检查发现异常的服务器后，Nginx会动态地将异常服务器在upstream中禁用，以实现更精准的故障转移。</p>
<p>三、set_by_lua_block<br>3.1　阶段说明<br><strong>语法：</strong>set_by_lua_block res {lua-script-str}<br><strong>配置环境：</strong>server，server if，location，location if<br><strong>阶段：</strong>rewrite<br><strong>含义：</strong>执行<lua-script-str>代码，并将返回的字符串赋值给res</p>
<p>3.2　变量赋值<br>本指令一次只能返回一个值，并赋值给变量res（即只有一个res（即只有一个res被赋值），示例如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  testnginx.com;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">set</span> $a <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">set_by_lua_block</span> $a &#123;</span><br><span class="line">         <span class="attribute">local</span> t = <span class="string">&#x27;tes&#x27;</span></span><br><span class="line">         return t</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">200</span> $a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<p>  curl <a target="_blank" rel="noopener" href="http://testnginx.com/">http://testnginx.com/</a><br>test</p>
<p>那如果希望返回多个变量，该怎么办呢？可以使用ngx.var.VARIABLE，示例如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  testnginx.com;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="comment">#使用ngx.var.VARIABLE前需先定义变量</span></span><br><span class="line">    <span class="attribute">set</span> $b <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">set_by_lua_block</span> $a &#123;</span><br><span class="line">        <span class="attribute">local</span> t = <span class="string">&#x27;test&#x27;</span></span><br><span class="line">        ngx.var.b = <span class="string">&#x27;test_b&#x27;</span></span><br><span class="line">        return t</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">200</span> $a,$b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<p>  curl <a target="_blank" rel="noopener" href="http://testnginx.com/test">http://testnginx.com/test</a><br>test,test_b</p>
<p>3.2　Rewrite阶段的混用模式<br>因为set_by_lua_block处在rewrite阶段，所以它可以和ngx_http_rewrite_module、set-misc-nginx-module，以及array-var-nginx-module一起使用，在代码执行时，按照配置文件的顺序从上到下执行，示例如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  testnginx.com;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">set</span> $a <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">    <span class="attribute">set_by_lua_block</span> $b &#123;</span><br><span class="line">        <span class="attribute">local</span> t = <span class="string">&#x27;bbb&#x27;</span></span><br><span class="line">        return t</span><br><span class="line">    &#125;</span><br><span class="line">    set_by_lua_block $c &#123;</span><br><span class="line">        <span class="attribute">local</span> t = <span class="string">&#x27;ccc&#x27;</span>  .. ngx.var.b</span><br><span class="line">        return t</span><br><span class="line">    &#125;</span><br><span class="line">    set $d <span class="string">&quot;456$c&quot;</span>; </span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> $a,$b,$c,$d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从执行结果可以看出数据是从上到下执行的，如下所示：</p>
<p> curl  <a target="_blank" rel="noopener" href="http://testnginx.com/test">http://testnginx.com/test</a><br>123,bbb,cccbbb,456cccbbb<br>1.<br>2.<br>3.3　阻塞事件<br>set_by_lua_block指令块在Nginx中执行的指令是阻塞型操作，因此应尽量在这个阶段执行轻、快、短、少的代码，以避免耗时过多。set_by_lua_block不支持非阻塞I/O，所以不支持yield当前Lua的轻线程。<br>3.4　被禁用的Lua API指令<br>在set_by_lua_block阶段的上下文中，下面的Lua API是被禁止的（只罗列部分）。<br>输出类型的API函数（如ngx.say和ngx.send_headers）。<br>控制类型的API函数（如ngx.exit）。<br>子请求的API函数（如ngx.location.capture和ngx.location.capture_multi）。<br>Cosocket API函数（如ngx.socket.tcp和ngx.req.socket）。<br>休眠API函数ngx.sleep。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/21/blog/go-interface/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/21/blog/go-interface/" class="post-title-link" itemprop="url">golang map初始化及使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-21 15:42:23" itemprop="dateCreated datePublished" datetime="2022-01-21T15:42:23+08:00">2022-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-25 15:23:51" itemprop="dateModified" datetime="2022-01-25T15:23:51+08:00">2022-01-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>golang中的接口分为带方法的接口和空接口。 带方法的接口在底层用iface表示，空接口的底层则是eface表示。下面我们透过底层分别看一下这两种类型的接口原理。</p>
<p>以下是接口的原型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//runtime/runtime2.go</span><br><span class="line"></span><br><span class="line">//非空接口</span><br><span class="line">type iface struct &#123;</span><br><span class="line">	tab  *itab</span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line">type itab struct &#123;</span><br><span class="line">	inter  *interfacetype</span><br><span class="line">	_type  *_type</span><br><span class="line">	link   *itab</span><br><span class="line">	hash   uint32 // copy of _type.hash. Used for type switches.</span><br><span class="line">	bad    bool   // type does not implement interface</span><br><span class="line">	inhash bool   // has this itab been added to hash?</span><br><span class="line">	unused [2]byte</span><br><span class="line">	fun    [1]uintptr // variable sized</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//******************************</span><br><span class="line"></span><br><span class="line">//空接口</span><br><span class="line">type eface struct &#123;</span><br><span class="line">	_type *_type</span><br><span class="line">	data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//========================</span><br><span class="line">//这两个接口共同的字段_type</span><br><span class="line">//========================</span><br><span class="line"></span><br><span class="line">//runtime/type.go</span><br><span class="line">type _type struct &#123;</span><br><span class="line">	size       uintptr</span><br><span class="line">	ptrdata    uintptr // size of memory prefix holding all pointers</span><br><span class="line">	hash       uint32</span><br><span class="line">	tflag      tflag</span><br><span class="line">	align      uint8</span><br><span class="line">	fieldalign uint8</span><br><span class="line">	kind       uint8</span><br><span class="line">	alg        *typeAlg</span><br><span class="line">	// gcdata stores the GC type data for the garbage collector.</span><br><span class="line">	// If the KindGCProg bit is set in kind, gcdata is a GC program.</span><br><span class="line">	// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span><br><span class="line">	gcdata    *byte</span><br><span class="line">	str       nameOff</span><br><span class="line">	ptrToThis typeOff</span><br><span class="line">&#125;</span><br><span class="line">//_type这个结构体是golang定义数据类型要用的，讲到反射文章的时候在具体讲解这个_type。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="1-iface"><a href="#1-iface" class="headerlink" title="1.iface"></a>1.iface</h1><h3 id="1-1-变量类型是如何转换成接口类型的？"><a href="#1-1-变量类型是如何转换成接口类型的？" class="headerlink" title="1.1 变量类型是如何转换成接口类型的？"></a>1.1 变量类型是如何转换成接口类型的？</h3><p>看下方代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">type Person interface &#123;</span><br><span class="line">   run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type xitehip struct &#123;</span><br><span class="line">   age uint8</span><br><span class="line">&#125;</span><br><span class="line">func (o xitehip)run() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">   var xh Person = xitehip&#123;age:18&#125;</span><br><span class="line">   xh.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>xh变量是Person接口类型，那xitehip的struct类型是如何转换成接口类型的呢？ 看一下生成的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0x001d 00029 (main.go:13)	PCDATA	$2, $0</span><br><span class="line">0x001d 00029 (main.go:13)	PCDATA	$0, $0</span><br><span class="line">0x001d 00029 (main.go:13)	MOVB	$0, &quot;&quot;..autotmp_1+39(SP)</span><br><span class="line">0x0022 00034 (main.go:13)	MOVB	$18, &quot;&quot;..autotmp_1+39(SP)</span><br><span class="line">0x0027 00039 (main.go:13)	PCDATA	$2, $1</span><br><span class="line">0x0027 00039 (main.go:13)	LEAQ	go.itab.&quot;&quot;.xitehip,&quot;&quot;.Person(SB), AX</span><br><span class="line">0x002e 00046 (main.go:13)	PCDATA	$2, $0</span><br><span class="line">0x002e 00046 (main.go:13)	MOVQ	AX, (SP)</span><br><span class="line">0x0032 00050 (main.go:13)	PCDATA	$2, $1</span><br><span class="line">0x0032 00050 (main.go:13)	LEAQ	&quot;&quot;..autotmp_1+39(SP), AX</span><br><span class="line">0x0037 00055 (main.go:13)	PCDATA	$2, $0</span><br><span class="line">0x0037 00055 (main.go:13)	MOVQ	AX, 8(SP)</span><br><span class="line">0x003c 00060 (main.go:13)	CALL	runtime.convT2Inoptr(SB)</span><br><span class="line">0x0041 00065 (main.go:13)	MOVQ	16(SP), AX</span><br><span class="line">0x0046 00070 (main.go:13)	PCDATA	$2, $2</span><br><span class="line">0x0046 00070 (main.go:13)	MOVQ	24(SP), CX</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>从汇编发现有个转换函数： runtime.convT2Inoptr(SB) 我们去看一下这个函数的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func convT2Inoptr(tab *itab, elem unsafe.Pointer) (i iface) &#123;</span><br><span class="line">        t := tab._type</span><br><span class="line">        if raceenabled &#123;</span><br><span class="line">                raceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2Inoptr))</span><br><span class="line">        &#125;</span><br><span class="line">        if msanenabled &#123;</span><br><span class="line">                msanread(elem, t.size)</span><br><span class="line">        &#125;</span><br><span class="line">        x := mallocgc(t.size, t, false)//为elem申请内存</span><br><span class="line">        memmove(x, elem, t.size)//将elem所指向的数据赋值到新的内存中</span><br><span class="line">        i.tab = tab //设置iface的tab</span><br><span class="line">        i.data = x //设置iface的data</span><br><span class="line">        return</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>从以上实现我们发现编译器生成的struct原始数据会复制一份，然后将新的数据地址赋值给iface.data从而生成了完整的iface，这样如下原始代码中的xh就转换成了Person接口类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var xh Person = xitehip&#123;age:18&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-指针变量类型是如何转换成接口类型的呢？"><a href="#1-2-指针变量类型是如何转换成接口类型的呢？" class="headerlink" title="1.2 指针变量类型是如何转换成接口类型的呢？"></a>1.2 指针变量类型是如何转换成接口类型的呢？</h3><p>还是上面的例子只是将</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xh Person = xitehip&#123;age:18&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>换成了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xh Person = &amp;xitehip&#123;age:18&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>那指针类型的变量是如何转换成接口类型的呢？ 见下方汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x001d 00029 (main.go:13)	PCDATA	$2, $1</span><br><span class="line">0x001d 00029 (main.go:13)	PCDATA	$0, $0</span><br><span class="line">0x001d 00029 (main.go:13)	LEAQ	type.&quot;&quot;.xitehip(SB), AX</span><br><span class="line">0x0024 00036 (main.go:13)	PCDATA	$2, $0</span><br><span class="line">0x0024 00036 (main.go:13)	MOVQ	AX, (SP)</span><br><span class="line">0x0028 00040 (main.go:13)	CALL	runtime.newobject(SB)</span><br><span class="line">0x002d 00045 (main.go:13)	PCDATA	$2, $1</span><br><span class="line">0x002d 00045 (main.go:13)	MOVQ	8(SP), AX</span><br><span class="line">0x0032 00050 (main.go:13)	MOVB	$18, (AX)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>发现了这个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runtime.newobject(SB)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>去看一下具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// implementation of new builtin</span><br><span class="line">// compiler (both frontend and SSA backend) knows the signature</span><br><span class="line">// of this function</span><br><span class="line">func newobject(typ *_type) unsafe.Pointer &#123;</span><br><span class="line">        return mallocgc(typ.size, typ, true)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>编译器自动生成了iface并将&amp;xitehip{age:18}创建的对象的地址（通过newobject）赋值给iface.data。就是xitehip这个结构体没有被复制</p>
<h3 id="1-4-接口调用规则"><a href="#1-4-接口调用规则" class="headerlink" title="1.4 接口调用规则"></a>1.4 接口调用规则</h3><p>把上面的例子添加一个eat()接口方法并实现它（注意这个接口方法的实现的接受者是指针）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">type Person interface &#123;</span><br><span class="line">	run()</span><br><span class="line">	eat(string)</span><br><span class="line">&#125;</span><br><span class="line">type xitehip struct &#123;</span><br><span class="line">	age uint8</span><br><span class="line">&#125;</span><br><span class="line">func (o xitehip)run() &#123; // //接收方o是值</span><br><span class="line">&#125;</span><br><span class="line">func (o *xitehip)eat(food string) &#123; //接收方o是指针</span><br><span class="line">&#125;</span><br><span class="line">func main()  &#123;</span><br><span class="line">	var xh Person = &amp;xitehip&#123;age:18&#125; //xh是指针</span><br><span class="line">	xh.eat(&quot;ma la xiao long xia!&quot;)</span><br><span class="line">	xh.run()</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这个例子的xh变量的实际类型是个指针，那它是如何调用非指针方法run的呢？</p>
<p>见下表总结：</p>
<table>
<thead>
<tr>
<th>调用方</th>
<th>接收方</th>
<th>能否编译</th>
</tr>
</thead>
<tbody><tr>
<td>值</td>
<td>值</td>
<td>true</td>
</tr>
<tr>
<td>值</td>
<td>指针</td>
<td><em>false</em></td>
</tr>
<tr>
<td>指针</td>
<td>值</td>
<td>true</td>
</tr>
<tr>
<td>指针</td>
<td>指针</td>
<td>true</td>
</tr>
<tr>
<td>指针</td>
<td>指针和值</td>
<td>true</td>
</tr>
<tr>
<td>值</td>
<td>指针和值</td>
<td><em>false</em></td>
</tr>
</tbody></table>
<p>从上表可以得出如下结论：</p>
<blockquote>
<p>  调用方是值时，只要接收方有指针方法那编译器不允许通过编译。</p>
</blockquote>
<h1 id="2-eface"><a href="#2-eface" class="headerlink" title="2 eface"></a>2 eface</h1><p>空接口相对于非空接口没有了方法列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type eface struct &#123;</span><br><span class="line">	_type *_type</span><br><span class="line">	data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>第一个属性由itab换成了_type,这个结构体是golang中的变量类型的基础，所以空接口可以指定任意变量类型。</p>
<h3 id="2-1-示例："><a href="#2-1-示例：" class="headerlink" title="2.1 示例："></a>2.1 示例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type xitehip struct &#123;</span><br><span class="line">&#125;</span><br><span class="line">func main()  &#123;</span><br><span class="line">	var a interface&#123;&#125; = xitehip&#123;&#125;</span><br><span class="line">	var b interface&#123;&#125; = &amp;xitehip&#123;&#125;</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/21/blog/go-map%E5%88%9D%E5%A7%8B%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/21/blog/go-map%E5%88%9D%E5%A7%8B%E5%8C%96/" class="post-title-link" itemprop="url">golang map初始化及使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-21 15:42:23" itemprop="dateCreated datePublished" datetime="2022-01-21T15:42:23+08:00">2022-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-24 10:35:43" itemprop="dateModified" datetime="2022-01-24T10:35:43+08:00">2022-01-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>特点：</p>
<ul>
<li>  类似其它语言中的哈希表或字典，以key-value形式存储数据</li>
<li>  key必须是支持==或!=比较运算的类型，不可以是函数、map或slice</li>
<li>  Map通过key查找value比线性搜索快很多</li>
<li>  Map使用make()创建，支持:=这种简写方式</li>
<li>  make([keyType]valueType,cap),cap表示容量，可省略</li>
<li>  超出容量时会自动扩容，但尽量提供一个合理的初始值</li>
<li>  使用len()获取元素个数</li>
<li>  键值对不存在时自动添加，使用delete()删除某键值对</li>
<li>  使用for range对map和slice进行迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先声明map</span></span><br><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 再使用make函数创建一个非nil的map，nil map不能赋值</span></span><br><span class="line">m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="comment">// 最后给已声明的map赋值</span></span><br><span class="line">m1[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;aa&quot;</span></span><br><span class="line">m1[<span class="string">&quot;b&quot;</span>] = <span class="string">&quot;bb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接创建</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="comment">// 然后赋值</span></span><br><span class="line">m2[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;aa&quot;</span></span><br><span class="line">m2[<span class="string">&quot;b&quot;</span>] = <span class="string">&quot;bb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 + 赋值一体化</span></span><br><span class="line">m3 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">	<span class="string">&quot;a&quot;</span>: <span class="string">&quot;aa&quot;</span>,</span><br><span class="line">	<span class="string">&quot;b&quot;</span>: <span class="string">&quot;bb&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==========================================</span></span><br><span class="line"><span class="comment">// 查找键值是否存在</span></span><br><span class="line"><span class="keyword">if</span> v, ok := m1[<span class="string">&quot;a&quot;</span>]; ok &#123;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Key Not Found&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历map</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">	fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历map</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">	fmt.Println(k, m1[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/21/blog/golang-pool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/21/blog/golang-pool/" class="post-title-link" itemprop="url">Go sync.Pool</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-21 15:41:46" itemprop="dateCreated datePublished" datetime="2022-01-21T15:41:46+08:00">2022-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-24 10:35:43" itemprop="dateModified" datetime="2022-01-24T10:35:43+08:00">2022-01-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>hello world</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/21/blog/error_page/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/21/blog/error_page/" class="post-title-link" itemprop="url">nginx错误页面error_page</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-21 10:50:31" itemprop="dateCreated datePublished" datetime="2022-01-21T10:50:31+08:00">2022-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-24 10:35:43" itemprop="dateModified" datetime="2022-01-24T10:35:43+08:00">2022-01-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近网上看到这几篇文章，这里记录一下，分享给大家<br>nginx要自定义404和401的页面，但是error_page 配置没有生效，没有正常跳转。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">error_page</span> <span class="number">404</span>  /<span class="number">404</span>.html;</span><br><span class="line"><span class="attribute">error_page</span> <span class="number">404</span> = http://www.test.com/error.html;</span><br><span class="line">http://tengine.taobao.org/nginx_docs/cn/docs/http/ngx_http_core_module.html<span class="comment">#error_page</span></span><br></pre></td></tr></table></figure>
<p>这是因为我们的404静态资源在上游服务器上，而不是当前nginx直接提供</p>
<p><strong>nginx proxy 启用自定义错误页面：</strong></p>
<p>语法:proxy_intercept_errors on | off;<br>默认值:<br>proxy_intercept_errors off;<br>上下文:http, server, location<br><strong><u>当被代理的后端服务器的响应状态码大于等于300时，决定是否直接将响应发送给客户端，亦或将响应转发给nginx由error_page指令来处理。</u></strong><br><strong><u>proxy_intercept_errors 为on 表示 nginx按照原response code 输出，后端是404就是404。这个变量开启后，我们才能自定义错误页面。</u></strong></p>
<p><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors">http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors</a></p>
<h4 id="一、Nginx在Linux上设置404错误页面"><a href="#一、Nginx在Linux上设置404错误页面" class="headerlink" title="一、Nginx在Linux上设置404错误页面"></a>一、Nginx在Linux上设置404错误页面</h4><p>Linux版本：Centos 7.4<br>Nginx版本：nginx-1.14.0.tar.gz<br>nginx安装目录参考： /usr/local/nginx则是我的安装目录<br>说明：我Linux服务器上已经在tomcat上部署了一个项目，使用Nginx进行的代理， 访问项目不存在的页面时，出现的是Nginx默认的404页面，现在我配置我自己写的404页面进行提示</p>
<p>注意：网上大多数博客写的都只有一种情况，要么就是使用 proxy_intercept_errors on;， 要么就是使用fastcgi_intercept_errors on; 没有说明这两种的区别， 还有也没有说明404.html文件应该放在服务器的什么位置。</p>
<p>我在此处优先进行说明：<br>1、如果你本地有部署项目，优先使用proxy_intercept_errors on;这个配置进行尝试，<br>2、如果没有部署项目，则使用fastcgi_intercept_errors on; 这个进行尝试，<br>3、也可以两个全加上， 其次404.html文件放在nginx安装目录的html文件夹下</p>
<h5 id="1-1-第一种配置情况（跳转网络地址）"><a href="#1-1-第一种配置情况（跳转网络地址）" class="headerlink" title="1.1 第一种配置情况（跳转网络地址）"></a>1.1 第一种配置情况（跳转网络地址）</h5><p>error_page配置的是http这种的网络地址</p>
<p>在http下配置 proxy_intercept_errors on;</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_intercept_errors</span> <span class="literal">on</span>;</span><br><span class="line">... 以下省略</span><br></pre></td></tr></table></figure>
<p>在server下配置 error_page 以下两种情况都可以起作用：<br>1、error_page 可以配置在server第一层的任何位置， 不受影响<br>2、error_page 也可以配置在location里面</p>
<p>我下面代码注释的地方都是可以配置的</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.xxxxxxx.com;</span><br><span class="line">    <span class="comment">#error_page  404  http://www.baidu.com;</span></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://search-masteryee;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   REMOTE-HOST $remote_addr;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   Host $host; </span><br><span class="line">        <span class="attribute">proxy_set_header</span>   X-Real-IP $remote_addr; </span><br><span class="line">        <span class="attribute">proxy_set_header</span>   X-Forwarded-For 	$proxy_add_x_forwarded_for;</span><br><span class="line">        <span class="attribute">client_max_body_size</span>    <span class="number">20m</span>; </span><br><span class="line">        <span class="comment">#error_page  404  http://www.baidu.com;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /upload &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>  <span class="number">404</span>  http://www.baidu.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-2-第二种配置情况（跳转本地地址）"><a href="#1-2-第二种配置情况（跳转本地地址）" class="headerlink" title="1.2 第二种配置情况（跳转本地地址）"></a>1.2 第二种配置情况（跳转本地地址）</h5><p>error_page配置的是本地服务器的页面地址,</p>
<p>说明：<br>我的404.html页面文件放在nginx安装目录下的html文件夹内<br>如果编写的404.html页面中有图片等外部文件，使用相对地址是不行的<br>在http下配置 proxy_intercept_errors on;</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_intercept_errors</span> <span class="literal">on</span>;</span><br><span class="line">... 以下省略</span><br></pre></td></tr></table></figure>
<p>在server中配置error_page 说明：我的nginx安装在/usr/local/下</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.xxxxxxx.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://search-masteryee;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   REMOTE-HOST $remote_addr;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   Host $host; </span><br><span class="line">        <span class="attribute">proxy_set_header</span>   X-Real-IP $remote_addr; </span><br><span class="line">        <span class="attribute">proxy_set_header</span>   X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        <span class="attribute">client_max_body_size</span>    <span class="number">20m</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /upload &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">404</span>  /<span class="number">404</span>.html;</span><br><span class="line">    <span class="attribute">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">        <span class="comment">#使用绝对地址， 跳转服务器/usr/local/nginx/html/404.html</span></span><br><span class="line">        <span class="attribute">root</span>   /usr/local/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这种方式和上面的方式均可起作用，只需要选择一种即可，本文中没有进行进一步注释</span></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">404</span>  /<span class="number">404</span>.html;</span><br><span class="line">    <span class="attribute">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">        <span class="comment"># 使用相对地址, 跳转nginx安装目录下的html/404.html</span></span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">        <span class="comment"># 下面这种多了一个/ 反而不起作用</span></span><br><span class="line">        <span class="comment">#root   /html;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 以下这几种网上比较多的方式，均试过，无法跳转正确页面或不起跳转作用</span></span><br><span class="line">    <span class="comment">#error_page   404  404.html;</span></span><br><span class="line">    <span class="comment">#error_page   404  /404.html;</span></span><br><span class="line">    <span class="comment">#error_page   404  html/404.html;</span></span><br><span class="line">    <span class="comment">#error_page   404  /html/404.html;</span></span><br><span class="line">    <span class="comment">#error_page   404  /usr/local/nginx/html/404.html;</span></span><br><span class="line">    <span class="comment">#error_page   404  usr/local/nginx/html/404.html;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以配置多种返回码的多个错误页面，也可以同时配置多个错误码跳转一个页面，可以同时存在 如下所示</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.xxxxxxx.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://search-masteryee;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   REMOTE-HOST $remote_addr;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   Host $host; </span><br><span class="line">        <span class="attribute">proxy_set_header</span>   X-Real-IP $remote_addr; </span><br><span class="line">        <span class="attribute">proxy_set_header</span>   X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        <span class="attribute">client_max_body_size</span>    <span class="number">20m</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /upload &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404	/404.html;</span></span><br><span class="line">    <span class="comment"># 错误页面的种类也可以是多个</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里的错误码可以是多个</span></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里是错误吗也可以是一个</span></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">404</span>  /<span class="number">404</span>.html;</span><br><span class="line">    <span class="attribute">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-3-第三种情况（tomcat未启动时）"><a href="#1-3-第三种情况（tomcat未启动时）" class="headerlink" title="1.3 第三种情况（tomcat未启动时）"></a>1.3 第三种情况（tomcat未启动时）</h5><p>当我把我的tomcat服务器关掉时，我服务器就没有运行项目了，这时在访问页面，则上述配置没有产生效果，此时则需要添加一个配置 fastcgi_intercept_errors on;</p>
<p>在http下配置 fastcgi_intercept_errors on;</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">fastcgi_intercept_errors</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">proxy_intercept_errors</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#   </span></span><br></pre></td></tr></table></figure>
<p>server中配置如下，将500 502 503 504等状态码一致性跳转404页面</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.xxxxxxx.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://search-masteryee;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   REMOTE-HOST $remote_addr;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   Host $host; </span><br><span class="line">        <span class="attribute">proxy_set_header</span>   X-Real-IP $remote_addr; </span><br><span class="line">        <span class="attribute">proxy_set_header</span>   X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        <span class="attribute">client_max_body_size</span>    <span class="number">20m</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /upload &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404	/404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">404</span>.html;</span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">404</span>  /<span class="number">404</span>.html;</span><br><span class="line">    <span class="attribute">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-4-第四种情况（proxy-intercept-errors的配置地址可多样）"><a href="#1-4-第四种情况（proxy-intercept-errors的配置地址可多样）" class="headerlink" title="1.4 第四种情况（proxy_intercept_errors的配置地址可多样）"></a>1.4 第四种情况（proxy_intercept_errors的配置地址可多样）</h5><p>proxy_intercept_errors on;这个配置不一定需要放在http下面，也可以是server下，也可以是server的location下</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.masteryee.com;</span><br><span class="line">    <span class="attribute">proxy_intercept_errors</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://search-masteryee;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   REMOTE-HOST $remote_addr;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   Host $host; </span><br><span class="line">        <span class="attribute">proxy_set_header</span>   X-Real-IP $remote_addr; </span><br><span class="line">        <span class="attribute">proxy_set_header</span>   X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        <span class="attribute">client_max_body_size</span>    <span class="number">20m</span>; </span><br><span class="line">        <span class="comment">#可以是这里</span></span><br><span class="line">        <span class="comment">#proxy_intercept_errors on;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> /upload &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">404</span>.html;</span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">404</span>  /<span class="number">404</span>.html;</span><br><span class="line">    <span class="attribute">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="1-5-proxy-intercept-errors和fastcgi-intercept-errors的理解"><a href="#1-5-proxy-intercept-errors和fastcgi-intercept-errors的理解" class="headerlink" title="1.5 proxy_intercept_errors和fastcgi_intercept_errors的理解"></a>1.5 proxy_intercept_errors和fastcgi_intercept_errors的理解</h6><p>配置proxy_intercept_errors on; 时配置的错误页面表示的是当服务器返回的状态码为配置的状态码时，才进行页面跳转。如：服务器中没有xxxx.do接口时，访问了这个接口，配置了 proxy_intercept_errors on;则也会进行页面跳转</p>
<p>如果服务器中没有开启服务，则配置proxy_intercept_errors on; 无用，则需要再添加fastcgi_intercept_errors on; 配置， 这样的话，出现页面错误时也会进行跳转</p>
<h4 id="2-Nginx自定义404页面3种方法"><a href="#2-Nginx自定义404页面3种方法" class="headerlink" title="2 Nginx自定义404页面3种方法"></a>2 Nginx自定义404页面3种方法</h4><p>一个网站项目，肯定是避免不了404页面的，通常使用Nginx作为Web服务器时，有以下集中配置方式，一起来看看。</p>
<h5 id="第一种：Nginx自己的错误页面"><a href="#第一种：Nginx自己的错误页面" class="headerlink" title="第一种：Nginx自己的错误页面"></a>第一种：Nginx自己的错误页面</h5><p>Nginx访问一个静态的html 页面，当这个页面没有的时候，Nginx抛出404，那么如何返回给客户端404呢？</p>
<p>看下面的配置，这种情况下不需要修改任何参数，就能实现这个功能。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>      <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.test.com;</span><br><span class="line">    <span class="attribute">root</span>   /var/www/test;</span><br><span class="line">    <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义错误页面码，如果出现相应的错误页面码，转发到那里。</span></span><br><span class="line">    <span class="attribute">error_page</span>  <span class="number">404</span> <span class="number">403</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">404</span>.html;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 承接上面的location。</span></span><br><span class="line">    <span class="attribute">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">        <span class="comment"># 放错误页面的目录路径。</span></span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="第二种：反向代理的错误页面"><a href="#第二种：反向代理的错误页面" class="headerlink" title="第二种：反向代理的错误页面"></a>第二种：反向代理的错误页面</h5><p>如果后台Tomcat处理报错抛出404，想把这个状态叫Nginx反馈给客户端或者重定向到某个连接，配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">upstream</span> www &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.201:7777</span>  weight=<span class="number">20</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">    ip_hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.test.com;</span><br><span class="line">    <span class="attribute">root</span>   /var/www/test;</span><br><span class="line">    <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">if</span> ($request_uri <span class="regexp">~* ‘^/$’)</span> &#123;</span><br><span class="line">            <span class="attribute">rewrite</span> .*   http://www.test.com/index.html <span class="literal">redirect</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关键参数：这个变量开启后，我们才能自定义错误页面，当后端返回404，nginx拦截错误定义错误页面</span></span><br><span class="line">        <span class="attribute">proxy_intercept_errors</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_pass</span>      http://www;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> HOST   $host;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP      $remote_addr;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-FOR $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>    <span class="number">404</span>  /<span class="number">404</span>.html;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="第三种：Nginx解析php代码的错误页面"><a href="#第三种：Nginx解析php代码的错误页面" class="headerlink" title="第三种：Nginx解析php代码的错误页面"></a>第三种：Nginx解析php代码的错误页面</h5><p>如果后端是php解析的，需要加一个变量</p>
<p>在http段中加一个变量 fastcgi_intercept_errors on 就可以了。</p>
<p>指定一个错误页面：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">error_page</span>    <span class="number">404</span>  /<span class="number">404</span>.html;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">    <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>指定一个url地址：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">error_page</span> <span class="number">404</span>  /<span class="number">404</span>.html;</span><br><span class="line"><span class="attribute">error_page</span> <span class="number">404</span> = http://www.test.com/error.html;</span><br></pre></td></tr></table></figure>
<p>参考：<br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1488582">https://cloud.tencent.com/developer/article/1488582</a></p>
<p><a target="_blank" rel="noopener" href="https://www.centos.bz/2017/08/nginx-custom-404-page/">https://www.centos.bz/2017/08/nginx-custom-404-page/</a><br>————————————————</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/21/blog/go-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/21/blog/go-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">Go 语言中进行目录遍历</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-21 10:50:31" itemprop="dateCreated datePublished" datetime="2022-01-21T10:50:31+08:00">2022-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-24 10:35:43" itemprop="dateModified" datetime="2022-01-24T10:35:43+08:00">2022-01-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Go 语言中进行目录遍历的原生方法主要是以下3种：<br>filepath.Walk()<br>ioutil.ReadDir()<br>os.File.Readdir()</p>
<p>性能是越底层越高（上层其实是对底层API的封装）。</p>
<hr>
<p>filepath.Walk()遍历根目录(root)下的文件树，为树中的每个文件或目录(包括根目录)调用walkFn。所有在访问文件和目录时出现的错误都由walkFn过滤。遍历按词法顺序进行，这使得输出是确定的，但对于非常大的目录来说，遍历可能是低效的。filepath.Walk()不会跟进符号链接。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://rosettacode.org/wiki/Walk_a_directory/Recursively#Go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    layout = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VisitFile</span><span class="params">(fp <span class="keyword">string</span>, fi os.FileInfo, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err) <span class="comment">// can&#x27;t walk here,</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>       <span class="comment">// but continue walking elsewhere</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> fi.IsDir() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// not a file.  ignore.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 过滤输出内容</span></span><br><span class="line">    matched, err := filepath.Match(<span class="string">&quot;*.txt&quot;</span>, fi.Name())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err) <span class="comment">// malformed pattern</span></span><br><span class="line">        <span class="keyword">return</span> err       <span class="comment">// this is fatal.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> matched &#123;</span><br><span class="line">        <span class="comment">// fmt.Println(fp)</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;Name: %s, ModifyTime: %s, Size: %v\n&quot;</span>, fp, fi.ModTime().Format(layout), fi.Size())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> path = flag.String(<span class="string">&quot;path&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;The path to traverse.&quot;</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    filepath.Walk(*path, VisitFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>filepath.Walk()会自动遍历子目录</strong>，但有些时候我们不希望这样，如果只想看当前目录，或手动指定某几级目录中的文件，这个时候，可以使用 ioutil.ReadDir 进行替代。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> path = flag.String(<span class="string">&quot;path&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;The path to traverse.&quot;</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    files, err := ioutil.ReadDir(*path)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">        fmt.Println(file.Name())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几个方法封装的一个演示和对比：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://stackoverflow.com/questions/14668850/list-directory-in-go/49196644#49196644</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        root  <span class="keyword">string</span></span><br><span class="line">        files []<span class="keyword">string</span></span><br><span class="line">        err   error</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// root = &quot;/home/manigandan/Desktop/Manigandan/sample&quot;</span></span><br><span class="line">    root = <span class="string">&quot;.&quot;</span></span><br><span class="line">    <span class="comment">// filepath.Walk</span></span><br><span class="line">    files, err = FilePathWalkDir(root)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ioutil.ReadDir</span></span><br><span class="line">    files, err = IOReadDir(root)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//os.File.Readdir</span></span><br><span class="line">    files, err = OSReadDir(root)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">        fmt.Println(file)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FilePathWalkDir</span><span class="params">(root <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> files []<span class="keyword">string</span></span><br><span class="line">    err := filepath.Walk(root, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="keyword">string</span>, info os.FileInfo, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !info.IsDir() &#123;</span><br><span class="line">            files = <span class="built_in">append</span>(files, path)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> files, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IOReadDir</span><span class="params">(root <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> files []<span class="keyword">string</span></span><br><span class="line">    fileInfo, err := ioutil.ReadDir(root)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> files, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> fileInfo &#123;</span><br><span class="line">        files = <span class="built_in">append</span>(files, file.Name())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> files, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OSReadDir</span><span class="params">(root <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> files []<span class="keyword">string</span></span><br><span class="line">    f, err := os.Open(root)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> files, err</span><br><span class="line">    &#125;</span><br><span class="line">    fileInfo, err := f.Readdir(<span class="number">-1</span>)</span><br><span class="line">    f.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> files, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> fileInfo &#123;</span><br><span class="line">        files = <span class="built_in">append</span>(files, file.Name())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> files, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/21/blog/hexo-blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/21/blog/hexo-blog/" class="post-title-link" itemprop="url">创建自己的blog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-21 10:50:31" itemprop="dateCreated datePublished" datetime="2022-01-21T10:50:31+08:00">2022-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-24 10:35:43" itemprop="dateModified" datetime="2022-01-24T10:35:43+08:00">2022-01-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、创建一个repository"><a href="#1、创建一个repository" class="headerlink" title="1、创建一个repository"></a>1、创建一个repository</h3><p>打开自己的github,创建一个名为“username.github.io”的项目，*<strong>注意：username必须是自己的github的用户名*</strong><br><img src=https://raw.githubusercontent.com/ycchildcoder/markdown/main/pages_create_repo.png width=700 height=500 />)</p>
<h4 id="1-1-Clone-the-repository"><a href="#1-1-Clone-the-repository" class="headerlink" title="1.1 Clone the repository"></a>1.1 Clone the repository</h4><p>克隆项目</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/username/username.github.io</span><br></pre></td></tr></table></figure>

<h4 id="1-2-Hello-World"><a href="#1-2-Hello-World" class="headerlink" title="1.2  Hello World"></a>1.2  Hello World</h4><p>进入到你克隆下来的项目目录里，添加一个html文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd username.github.io</span><br><span class="line">echo &quot;Hello World&quot; &gt; index.html</span><br></pre></td></tr></table></figure>

<h4 id="1-3-Push-it"><a href="#1-3-Push-it" class="headerlink" title="1.3 Push it"></a>1.3 Push it</h4><p>把它推到github上，Add, commit, and push your changes:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add --all</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h4 id="1-4-访问"><a href="#1-4-访问" class="headerlink" title="1.4 访问"></a>1.4 访问</h4><p>最后访问你的website ***<a target="_blank" rel="noopener" href="http://username.github.io/">http://username.github.io</a>***</p>
<h3 id="2、安装hexo"><a href="#2、安装hexo" class="headerlink" title="2、安装hexo"></a>2、安装hexo</h3><p>一个免费的域名外加一个只能写静态页面的server。现在你只需要更新一下你的html，git push到你对应的gitHub的repository上，外网就可以访问到你最新的内容。有人会说：“假如每次写博客都手动写一遍前端代码，太麻烦了，写完了还得自己发布到github,有没有一种工具可以帮我们干这件事呢？” 答案是有的，例如<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">*<strong>Hexo*</strong></a>。</p>
<p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p>
<p>Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)<br>Git</p>
<h4 id="2-1-安装nodejs"><a href="#2-1-安装nodejs" class="headerlink" title="2.1 安装nodejs"></a>2.1 安装nodejs</h4><p>你可以根据不同平台系统选择你需要的 Node.js 安装包。</p>
<p>Node.js 历史版本下载地址：<a target="_blank" rel="noopener" href="https://nodejs.org/dist/">https://nodejs.org/dist/</a></p>
<p>注意：Linux 上安装 Node.js 需要安装 Python 2.6 或 2.7 ，不建议安装 Python 3.0 以上版本。</p>
<h4 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h4><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否安装了Node.js和Git。<br>如果电脑上已经装完了Node.js和Git,则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>

<h4 id="2-3-建站"><a href="#2-3-建站" class="headerlink" title="2.3 建站"></a>2.3 建站</h4><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install </span><br></pre></td></tr></table></figure>

<p>输入一下指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate  (此指令可以简化为:hexo g)</span><br><span class="line">hexo server （此指令可以简化为:hexo s）</span><br></pre></td></tr></table></figure>

<p>启动服务器。默认情况下，访问网址为： <a target="_blank" rel="noopener" href="http://localhost:4000/">http://localhost:4000/</a></p>
<h4 id="2-4-部署"><a href="#2-4-部署" class="headerlink" title="2.4 部署"></a>2.4 部署</h4><p>推送生成的html代码到github，以便外网访问。</p>
<p>到blog的根目录下。打开_config.yml配置文件。翻到最后一行，编辑deploy相关的信息。内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://your_git_token@github.com/i6448038/i6448038.github.io.git   你的github仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>配置结束以后。输入以下指令，把代码自动部署到github。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy （此指令可以简化为：hexo d）</span><br></pre></td></tr></table></figure>

<p>如果你输入以上指令后没有反应，那么你应该：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>成功后，你就可以访问自己的gitPages了，<a target="_blank" rel="noopener" href="https://username.github.io/">https://username.github.io</a></p>
<h4 id="2-5-写博客"><a href="#2-5-写博客" class="headerlink" title="2.5 写博客"></a>2.5 写博客</h4><p>打开gitPages后发现都是程序默认生成的东西，现在需要自己写自己博客的内容了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;文章题目&quot;  (此指令可以简化:hexo n &quot;文章题目&quot;)</span><br></pre></td></tr></table></figure>

<p>关于MarkDown的编辑器，也多种多样，Atom、sublime、Mou、甚至vim也可以。</p>
<p>写完内容后，如果想改变当前博客的风格，可以去Hexo Themes的官网选择自己喜欢的风格。 <a target="_blank" rel="noopener" href="https://hexo.io/themes/">https://hexo.io/themes/</a><br>打开网址：<br><img src="https://raw.githubusercontent.com/ycchildcoder/markdown/main/website.png" alt="img"><br>点击喜欢的内容，会自动打开到该theme的gitHub仓库。</p>
<p>Aloha对应的gitHub仓库：</p>
<p> <a target="_blank" rel="noopener" href="https://github.com/henryhuang/hexo-theme-aloha.git">https://github.com/henryhuang/hexo-theme-aloha.git</a> </p>
<p>然后你需要做如下操作:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd $YOUR_BLOG_ROOT_DIR </span><br><span class="line">$ git clone https://github.com/henryhuang/hexo-theme-aloha.git themes/aloha</span><br></pre></td></tr></table></figure>

<p>然后更改当前文件夹下的_config.yml，把该文件中theme的值改为aloha。除此之外，如果你想更改该风格的站点菜单栏字段等文本内容，可以去theme文件夹下的aloha子文件夹下的__config.yml文件中修改。<br>然后执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>浏览器打开 <a target="_blank" rel="noopener" href="http://localhost:4000/">http://localhost:4000</a> 看看风格是否改变</p>
<h3 id="3-自动化"><a href="#3-自动化" class="headerlink" title="3 自动化"></a>3 自动化</h3><h4 id="3-1-启动本地hexo"><a href="#3-1-启动本地hexo" class="headerlink" title="3.1 启动本地hexo"></a>3.1 启动本地hexo</h4><p>bat脚本启动hexo本地服务器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">E:</span><br><span class="line">cd E:\blog\blog</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h4 id="3-2-部署hexo-博客"><a href="#3-2-部署hexo-博客" class="headerlink" title="3.2 部署hexo 博客"></a>3.2 部署hexo 博客</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">E:</span><br><span class="line">cd E:\blog\blog</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/20/blog/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ycchildcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ycchildcoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/20/blog/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-20 15:41:46" itemprop="dateCreated datePublished" datetime="2022-01-20T15:41:46+08:00">2022-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-24 14:17:57" itemprop="dateModified" datetime="2022-01-24T14:17:57+08:00">2022-01-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ycchildcoder</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ycchildcoder</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
